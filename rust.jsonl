{'image': 'https://tryhackme-images.s3.amazonaws.com/room-icons/d91add8e1561f11455130857e6d0aef9.png', 'title': 'Learn Rust', 'description': "Learn Rust for someone who knows programming but doesn't know low level programming", 'code': 'rust', 'users': 3144, 'tags': ['security', 'rust', 'accessible'], 'type': 'walkthrough', 'difficulty': 'easy', 'userCompleted': False, 'upVotes': 251, 'created': '2020-09-16T20:15:39.656Z', 'published': '2020-09-16T19:00:00.254Z', 'freeToUse': True, 'businessOnly': False, 'headerImage': 'https://assets.tryhackme.com/img/banners/default_tryhackme.png', 'creator': 'bee', 'tasks': [{'taskTitle': 'What is Rust?', 'taskDesc': '<p></p><p></p><p></p><p></p><p></p><p><img style="width:25%;float:right" src="https://rustacean.net/assets/cuddlyferris.svg" class="note-float-right" /></p><p><br /></p><p><b>Found an issue in this room? </b>Leave a message in Discord and someone will tag me if I don\'t see it :)</p><p><b>Reminder</b> This is a walk through room with no extra points for first bloods. Please take your time, copy the copy and experiment with it.</p><p>The attached file is this entire room, but as a PDF. If you are having accessibility issues with this room, refer to the PDF which may be much better interpreted. </p><p><i>The Crab is Rust\'s mascot and is taken from <a href="https://rustacean.net/" target="_blank">here</a>. All other images are taken from <a href="https://undraw.co/" target="_blank">Undraw.</a></i><br /></p><h2>Introduction<br /></h2><p>Rust is a new programming language created in 2015 by a small team of \npeople, and later adopted by Mozilla (the organisation that created \n&amp; maintains Firefox).</p>\n<p>It is a compiled low level language, which aims (and succeeds) to be the same speed as C++, but while incorporating some higher level language features from fan-favorites such as Python or JavaScript.</p>\n<p>Rust has 3 goals:</p>\n<ul><li>Fast</li><li>Secure</li><li>Productive</li></ul><h2>Fast</h2>\n<p>Rust aims to be similar in terms of performance to C++.</p>\n<p>Rust is statically typed, which means the data type of a variable is known at compile time. This allows the compiler to optimise the code further than if we didn\'t know the types.</p>\n<p>Rust does not use garbage collection (despite being a low level programming language). Garbage collection is where the program attempts to reclaim memory from garbage. Garbage is memory occupied by objects that are no longer in use by the program.</p>\n<p>Go, a high level programming language similar syntactically to Python but is fast &amp; compiled, uses garbage collection. This caused a massive overhead at Discord, which forced them to switch from Go to Rust. <a href="https://blog.discord.com/why-discord-is-switching-from-go-to-rust-a190bbca2b1f">https://blog.discord.com/why-discord-is-switching-from-go-to-rust-a190bbca2b1f</a></p>\n<p>Something to note is that Python and JavaScript use garbage collection. These abstractions may cause issues (as in Discord\'s case), which is why many choose a low level programming language.</p><h2>Secure</h2>\n<p>Rust is completely memory safe. This means that exploits involving memory aren\'t possible in Rust, unless you explicitly specify unsafe Rust code.</p>\n<p>The <a href="https://msrc-blog.microsoft.com/2019/07/22/why-rust-for-safe-systems-programming/">Microsoft Security Response Centre</a> states that 70% of all CVE\'s MSRC assigns are memory safety issues. In Microsoft\'s own words:</p>\n<p>"This means that if that software had been written in\nRust, 70% of these security issues would most likely have been eliminated. And\nweâ€™re not the only company to <a href="https://hacks.mozilla.org/2019/02/rewriting-a-browser-component-in-rust/">have reported such findings</a>."</p>\n<p>Sometimes programmers must perform unsafe operations. Rust provides tools to wrap these unsafe actions so unsafe code can be statically enforced by the Rust compiler.</p>\n<p>The memory safety is guaranteed by the concept of ownership. All Rust code follows these rules:</p>\n<ul><li>Each value has a variable, called an owner.</li><li>There can only be one owner at a time.</li><li>When the owner goes out of scope, the value will be dropped.</li></ul>\n<p>Values can be moved or borrowed between variables, but no value can have more than 1 owner.</p>\n<p>Let\'s see an example of Python failing with this:</p><p><code>squares = (val * val for val in range(100))<br />print(min(squares))\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0 <br />print(max(squares))</code><br /></p><p>What we want is:</p><p><code>0<br />9801</code><br /></p>But what we get is:<p><br /></p><p><code>&gt;&gt;&gt; print(min(squares))<br />0<br />&gt;&gt;&gt; print(max(squares))<br />Traceback (most recent call last):<br />\xa0 File "&lt;stdin&gt;", line 1, in &lt;module&gt;<br />ValueError: max() arg is an empty sequence<br /></code><br /></p>This is because <span style="font-family:&quot;SFMono-Regular&quot;, Consolas, &quot;Liberation Mono&quot;, Menlo, Courier, monospace;line-height:normal;background:rgba(135,131,120,0.15);color:#EB5757;border-radius:3px;font-size:85%;padding:0.2em 0.4em">min</span> alters the variable squares. It\'s strange, because we just wanted the minimum â€” not to alter the whole variable!<p></p><p></p><p>In Rust, the same code is:</p><p><code>fn main()<br />\xa0\xa0 let squares = (0..100).map(|val| val * val); <br />\xa0\xa0 println!("{:?}", squares.min());\xa0\xa0 <br />\xa0\xa0 println!("{:?}", squares.max());\xa0\xa0\xa0\xa0\xa0 <br />}\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0 </code><br /></p><p>When we try to compile this, Rust tells us:</p><p><code>error[E0382]: use of moved value: `squares`<br />\xa0--&gt; ownership.rs:4:21<br />\xa0 |<br />3 |\xa0\xa0\xa0 println!("{:?}", squares.min());<br />\xa0 |\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0 ------- value moved here<br />4 |\xa0\xa0\xa0 println!("{:?}", squares.max());<br />\xa0 |\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0 ^^^^^^^ value used here after move<br />\xa0 |<br />\xa0 = note: move occurs because `squares` has type `std::iter::Map&lt;std::ops::Range&lt;i32&gt;, [closure@ownership.rs:2:31: 2:40]&gt;`, which does not implement the `Copy` trait</code><br /></p><p></p><p>I\'ll talk more about this in a later task, but the important part is that <strong>Python allows functions to alter variables they do not own, whereas Rust doesn\'t.</strong></p>\n<p>PS: Notice how the Rust compiler explicitly points out the values, the lines, the exact characters, where the error occurred as well as a full error message explaining why it won\'t allow that code. Whereas Python simply said <code>max() arg is an empty sequence</code>.</p><h2>Productivity</h2>\n<p></p><p></p><p></p><p>Rust\'s 3rd largest goal is a strange one. Productivity!</p>\n<p>Rust provides all of the tools developers need to be productive, shipped with the platform itself.</p><p><i>Note: The below list is read as:</i></p><ul><li><i>Tool</i></li></ul><p><i>Explanation of the above tool.</i><br /></p>\n<p>Some of these include:</p>\n<ul><li>Cargo</li></ul>\n<p>Rust\'s version of NPM or PyPi. Download packages others have created.</p>\n<ul><li>Clippy</li></ul>\n<p>Microsoft Clippy, but re-imagined for Rust to aid with development.</p>\n<ul><li>RustFmt</li></ul>\n<p>Automatically formats Rust code</p>\n<ul><li>Cargo Test</li></ul>\n<p>A built in testing application created by the Rust developers.</p>\n<ul><li>Cargo docs</li></ul>\n<p>Automatically generate documentation for your code, using documentation comments (written in Markdown). This documentation is then sent to <a href="http://docs.rs">docs.rs</a> upon publishing to Cargo. Not to mention that examples written in documentation are automatically tested for you. No more untested documentation examples!</p>\n<ul><li>Rust-Analyzer</li></ul>\n<p>Think IDE but more intelligent. Rust Analyzer clearly labels what is wrong with your code, why it is wrong, the exact characters that conflict and cause the error, and 90% of the time it provides an "auto-fix" function that automatically fixes these errors for you.</p>\n<ul><li>The Rust Book &amp; Docs</li></ul>\n<p>Rust has a book, called The Book which details everything you could want to know about Rust. Neatly chaptered, easily searchable and at your disposal for free. If this isn\'t good enough, thanks to Rust\'s documentation comments almost every library you\'ll use will have extensive documentation online.</p>\n<p>With all of these tools at your disposal, it is incredibly rare to compile a Rust program and have bugs in it. In fact, I have only experienced this once. 99% of the time, the tooling and language will have picked up on it long before I hit compile.</p><p><br /></p>\n<h2>Conclusion</h2><p>If you are looking for something extremely fast and memory safe but while maintaining good productivity, Rust is the language for you. </p><p>As Pentesters our job is offering solutions to developers. Telling Python developers that a low-level language is a good alternative sounds wacky at first. </p><p>But Rust can hold your hand, as it supports calls from functions written in other languages (foreign function interfacing).</p><p>We can use Rust to rewrite security or performance critical code which will cooperate with our existing codebase. </p><p>Here\'s an example of calling C code <code>extern "C" {<br />\xa0\xa0\xa0 fn abs(input: i32) -&gt; i32;<br />}<br /><br />fn main() {<br />\xa0\xa0\xa0 unsafe {<br />\xa0\xa0\xa0\xa0\xa0\xa0\xa0 println!("C believes that the absolute value of -3 is: {}", abs(-3));<br />\xa0\xa0\xa0 }<br />}</code><br /></p><p></p><p></p>', 'taskType': 'downloadable', 'taskNo': 1, 'taskCreated': '2020-08-09T20:17:19.281Z', 'taskDeadline': None, 'tasksInfo': [], 'uploadId': '5f308b4cf328682b0b8a67d2', 'questions': [{'questionNo': 1, 'question': 'What other language is Rust similar to in terms of performance?', 'hint': ''}, {'questionNo': 2, 'question': '<p>What famous company switched from Go to Rust, mentioned in this task?</p>', 'hint': ''}, {'questionNo': 3, 'question': "<p>Microsoft Security Centre reports what percentage of CVE's they assign are memory safety issues? Include the % sign.<br /></p>", 'hint': ''}, {'questionNo': 4, 'question': "<p>What is Rust's version of NPM or PyPi?</p>", 'hint': ''}]}, {'taskTitle': 'Installing & Tooling', 'taskDesc': '<p></p><p><img style="width:25%;float:right" src="https://i.imgur.com/9w6cJJQ.png" class="note-float-right" /><br /></p><p>Before we dive into the language, let\'s install Rust.</p>\n<p>Rust recommends using the tool <code>rustup</code> to manage multiple versions of Rust. If you are familiar with Python, you may have used virtualenvs to achieve a similar result. That is, different versions of Python on the same machine.</p>\n<p>This is another great tool created by the Rust team for productivity.</p>\n<p>Install RustUp with this command:</p><p><code>curl --proto \'=https\' --tlsv1.2 -sSf https://sh.rustup.rs | sh</code></p>\n\n\n\n\n<p></p><p>This command can also be found on the Rust website <a href="https://www.rust-lang.org/tools/install">https://www.rust-lang.org/tools/install</a></p>\n<p>This command will install the stable version of Rust for your OS.</p>\n<p>Rust comes in 3 flavours. Stable, Beta, and Nightly.</p>\n<p>Stable is the latest stable release of Rust (stable releases are usually shipped every 6 weeks). Beta updates periodically. Nightly updates when the language itself updates.<br /></p>\n<p>Now, let\'s install some Rust tools to aid our development.</p>\n<p>The command we just ran also installs <code>Cargo</code>,</p>\n<p>Cargo is the package manager for Rust. All the packages get uploaded to <a href="https://crates.io">https://crates.io</a> and does a lot of cool things.</p>\n<p>The 3 core Cargo commands are:</p><b>cargo install\n</b><p>Install a package from <a href="http://Crates.io">Crates.io</a></p><b>Cargo publish\n</b><p>Publish a package to <a href="http://crates.io">crates.io</a></p><b>Cargo update\n</b><p>Updates all of the local packages</p>\n<p>But, since we are developing RustCode there are 3 more important commands</p><b>Cargo test</b>\n<p>Run the tests for our code</p><b>Cargo fmt\n</b><p>Runs the formatting tool. This tool automatically formats your code (apply the argument <code>--all</code> to format all code). Similar to Python\'s Black but built in.</p><b>Cargo clippy\n</b><p>Microsoft Clippy but for Rust! Clippy will point out common errors in your code and help you correct them.</p>\n<p><strong>Community tools</strong></p>\n<p>There is one tool, that is a community based tool â€” that is seen as absolutely essential to the Rust ecosystem.</p>\n<p>That tool is Rust-Analyzer. Imagine an IDE but smarter and more advanced. Rust-Analyzer will analyse your code as you write it, spot errors before you compile &amp; provide an auto-fix option to automatically fix the errors.</p>\n<p>Rust-Analyzer states that their most supported version is VS Code, but they are available on many other platforms.</p>\n<p>Something cool to note is that the main tools of Rust are written by the Rust developers themselves. In languages like Python, we may argue over whether <code>setuptools</code> or <code>poetry</code> is right. Or whether <code>pytest</code> is better than <code>unittest</code>. Arguing over the right  tool to use is procrastination. Rust says "these are the tools you will use" and that\'s it. This boosts productivity, as you don\'t have to worry about what tools to use but can impede development as the tool may not be fully complete.</p>\n', 'taskType': 'none', 'taskNo': 2, 'taskCreated': '2020-08-09T20:35:17.711Z', 'taskDeadline': None, 'tasksInfo': [], 'uploadId': '', 'questions': [{'questionNo': 1, 'question': 'What is the tool we used to install Rust called?', 'hint': ''}, {'questionNo': 2, 'question': '<p>How do we install the package <span style="font-family:&quot;SFMono-Regular&quot;, Consolas, &quot;Liberation Mono&quot;, Menlo, Courier, monospace;line-height:normal;background:rgba(135,131,120,0.15);color:#EB5757;border-radius:3px;font-size:85%;padding:0.2em 0.4em">rustscan</span> using cargo?</p>', 'hint': ''}, {'questionNo': 3, 'question': '<p>What command do we run to format our code?</p>', 'hint': ''}]}, {'taskTitle': 'Hello, World!', 'taskDesc': '<p></p><p></p><p></p><p></p><p><img style="width:25%;float:right" src="https://i.imgur.com/5gMSViIl.png" class="note-float-right" />It wouldn\'t be a programming tutorial without a basic "Hello, World!".</p>\n<p>Create a new folder, and in the terminal type:</p>\n\n<p></p><p><code>cargo init</code><br /></p><p>This makes Cargo initialise a new Rust repository. Cargo will take care of most of the work for you.</p>\n<p>The file structure is as follows:</p>\n<p><code>- Cargo.toml<br />- src/<br />\xa0\xa0\xa0 - main.rs</code><br /></p><p><code>cargo.toml</code> is the configuration file for our Rust project. It includes our dependencies, project name, authors, the version of Rust we are using and more.</p>\n<p>When we have just ran <code>cargo init</code>, our file will look like this:</p>\n<p></p><p></p><p><code>[package]<br />name = "Hello_world"<br />version = "0.1.0"<br />authors = ["bee &lt;bee@fake.com&gt;"]<br />edition = "2018"<br /><br /># See more keys and their definitions at https://doc.rust-lang.org/cargo/reference/manifest.html<br /><br />[dependencies]</code><br /></p><p></p><p>Our <code>main.rs</code>file in the folder <code>src</code> is the main file where we write our code. Every single Rust project <strong>must</strong> have a main file, and every main file must have a main function.</p>\n<p></p><p><code>fn main() {<br />\xa0\xa0\xa0 println!("Hello, world!");<br />}</code><br /></p><p></p><p><strong>Fun fact</strong> In the original C book, "Hello, World!" is stylised with a capital letter on the word world.</p>\n<p>In Rust, we use curly braces to denote blocks of code. And a semi-colon to express the end of an expression.</p>\n<p>To print in Rust, we use the macro <code>println!</code>.</p>\n<p>We know <code>println</code> is a macro, as it is called with an exclamation mark. Macros, in a nutshell, allow us to write code that writes more code. To put it even simpler, we can create our own syntax that translate to different code.</p>\n<p>To run this program, we execute:</p>\n<p><code>cargo run</code></p>\n<p>This should result in:</p>\n<p></p><p><code>âžœ cargo run <br />\xa0\xa0 Compiling hello_world v0.1.0 (/tmp/hello_world)<br />\xa0\xa0\xa0 Finished dev [unoptimized + debuginfo] target(s) in 0.21s<br />\xa0\xa0\xa0\xa0 Running `target/debug/hello_world`<br />Hello, world!</code><br /></p><p></p><p>This command:</p>\n<ul><li>Compiles the code with the unoptimised build (to increase the speed of compilation)</li><li>Runs the code</li></ul>\n<p>You\'ll also notice a new folder has been created, <code>target</code>.</p>\n<p><code>target</code> contains the binaries for our project.</p>\n<p></p><p></p><p></p><p><code>- Cargo.toml<br />- src/<br />\xa0\xa0\xa0 - main.rs<br />- target/<br />\xa0\xa0\xa0 - debug/<br />\xa0\xa0\xa0 \xa0\xa0\xa0 = build/<br />\xa0\xa0\xa0 \xa0\xa0\xa0 - deps/<br />\xa0\xa0\xa0 \xa0\xa0\xa0 - examples/<br />\xa0\xa0\xa0 \xa0\xa0\xa0 - hello_world<br />\xa0\xa0\xa0 \xa0\xa0\xa0 - hello_world.d<br />\xa0\xa0\xa0 \xa0\xa0\xa0 - incremental/<br /></code><br /></p><p>Right now, the only important file is <code>hello_world</code></p>\n<p>This file is actually the binary for our program.</p>\n<p>We can tell its a binary by running ls -l in the directory</p><p><code>drwxr-xr-x\xa0\xa0\xa0 - bee 31 Jul 23:35 build<br />drwxr-xr-x\xa0\xa0\xa0 - bee 31 Jul 23:35 deps<br />drwxr-xr-x\xa0\xa0\xa0 - bee 31 Jul 23:35 examples<br />.rwxr-xr-x 2.9M bee 31 Jul 23:35 hello_world<br />.rw-r--r--\xa0\xa0 72 bee 31 Jul 23:35 hello_world.d<br />drwxr-xr-x\xa0\xa0\xa0 - bee 31 Jul 23:35 incremental</code><br /></p>\n<p>To build our project without running it, run:</p><p><code>cargo build</code><br /></p><p>And now we can run the binary directly.</p><p><code>./target/debug/hello_world</code><br /></p><p>This is exactly the same as <code>cargo run</code>, but 2 commands.</p>\n<p>When we want to build our project and optimise it, run it with the release profile:</p>\n<p></p><p></p><p><code>cargo build --release</code></p><p></p><p>Use the normal cargo build for quick checking of the code. Use the release argument to optimise the code to the maximum possible that the Rust compiler will allow.</p>\n<p>We call <code>--release</code> a profile, specifically the release profile. The Rust compiler has different levels of optimisation depending on what you want.</p><p></p><p></p><p></p>', 'taskType': 'none', 'taskNo': 3, 'taskCreated': '2020-08-09T20:41:36.037Z', 'taskDeadline': None, 'tasksInfo': [], 'uploadId': '', 'questions': [{'questionNo': 1, 'question': 'How do we initialise a new Rust project?', 'hint': ''}, {'questionNo': 2, 'question': '<p>What character represents a macro?</p>', 'hint': ''}, {'questionNo': 3, 'question': '<p>What does every Rust project need as a file?</p>', 'hint': ''}, {'questionNo': 4, 'question': '<p>If we wanted to add a dependency to our Rust project, what file would we edit?</p>', 'hint': ''}, {'questionNo': 5, 'question': '<p>How do we run our Rust project?</p>', 'hint': ''}, {'questionNo': 6, 'question': '<p>How do we build the project RustScan with the release profile (most optimised)?</p>', 'hint': ''}, {'questionNo': 7, 'question': '<p>What folder are the release binaries stored in?</p>', 'hint': "Hint: it is in the format x/y/. Don't forget the / on the end!"}, {'questionNo': 8, 'question': '<p>How many release profiles does Rust have using optimisation level?</p>', 'hint': 'inclusive'}]}, {'taskTitle': 'Variables', 'taskDesc': '<p><br /><br />\n<br /><br />\n<img src="https://i.imgur.com/FdKSM1J.png" alt /></p>\n<p>All variables, by default, are immutable in Rust.</p>\n<p>This is a safety feature, but also a productivity feature. Variables that don\'t change mean you don\'t have to track down when the value changed, and immutable variables are great for concurrency</p>\n<p>Let\'s see this in action.</p>\n<p><code>fn main() {</code><br />\n\xa0\xa0\xa0 let x = 5;<br />\n\xa0\xa0\xa0 println!("The value of x is: {}", x);<br />\n\xa0\xa0\xa0 x = 1;<br />\n\xa0\xa0\xa0 println!("The value of x is: {}", x);<br />\n}</p>\n<p><br /><br />\nThis code does not compile**.** It returns with the error:</p>\n<p><code>error[E0384]: cannot assign twice to immutable variable </code>x``<br />\n\xa0--&gt; src/main.rs:4:5<br />\n\xa0 |<br />\n2 |\xa0\xa0\xa0\xa0 let x = 5;<br />\n\xa0 |\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0 -<br />\n\xa0 |\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0 |<br />\n\xa0 |\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0 first assignment to `x`<br />\n\xa0 |\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0 help: make this binding mutable: `mut x`<br />\n3 |\xa0\xa0\xa0\xa0 println!("The value of x is: {}", x);<br />\n4 |\xa0\xa0\xa0\xa0 x = 1;<br />\n\xa0 |\xa0\xa0\xa0\xa0 ^^^^^ cannot assign twice to immutable variable</p>\n<p>The error tells us everything we need to know.</p>\n<p><code>cannot assign twice to immutable variable</code></p>\n<p>This is telling us that we are assigning a value to an immutable variable (a variable that cannot be changed), twice. Which cannot happen.</p>\n<p>It is important we get compile-time errors, as this can lead to bugs and undefined behaviour â€” which can lead to insecure code. In Rust, once an immutable variable is set Rust guarantees it will never change in its lifetime.</p>\n<p>To make a variable mutable, we place the mut keyword in front of it like so:<br />\n<code>fn main() { \xa0\xa0 \xa0let mut x = 9; \xa0\xa0 \xa0println!("The value of x is: {}", x); \xa0\xa0 \xa0let x = 4; \xa0\xa0 \xa0println!("The value of x is: {}", x); }</code><br />\nThis code compiles &amp; runs correctly:</p>\n<p><code>âžœ cargo run\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0</code><br />\n\xa0\xa0 Compiling hello_world v0.1.0 (/tmp/hello_world)<br />\n\xa0\xa0\xa0 Finished dev [unoptimized + debuginfo] target(s) in 0.14s<br />\n\xa0\xa0\xa0\xa0 Running `target/debug/hello_world`<br />\nThe value of x is: 9<br />\nThe value of x is: 4</p>\n<p>Being unable to change the value of a variable might have reminded you of another programming concept that most other languages have: constants. Like immutable variables, constants are values that are bound to a name and are not allowed to change, but there are a few differences between constants and variables.</p>\n<p>Refer to this code for the tasks.</p>\n<p><strong>Question 1</strong></p>\n<p><code>fn main() {</code><br />\n\xa0\xa0\xa0 let x: u32 = 5;<br />\n\xa0\xa0\xa0 println!("The value of x is: {}", x);<br />\n\xa0\xa0\xa0 x = "hello";<br />\n\xa0\xa0\xa0 println!("The value of x is: {}", x);<br />\n}</p>\n<p><br /><br />\n<strong>Question 2</strong></p>\n<p><code>fn main() {</code><br />\n\xa0\xa0\xa0 let x: u32 = 5;<br />\n\xa0\xa0\xa0 println!("The value of x is: {}", x);<br />\n\xa0\xa0\xa0 x = 5;<br />\n\xa0\xa0\xa0 println!("The value of x is: {}", x);<br />\n}</p>\n', 'taskType': 'none', 'taskNo': 4, 'taskCreated': '2020-08-09T20:53:27.439Z', 'taskDeadline': None, 'tasksInfo': [], 'uploadId': '', 'questions': [{'questionNo': 1, 'question': '<p>In question 1, does this code compile? T(rue) or F(alse)</p>\n', 'hint': ''}, {'questionNo': 2, 'question': '<p>What is the error code returned by question 1?</p>\n', 'hint': ''}, {'questionNo': 3, 'question': '<p>Does the code in question 2 compile? T(rue) or F(alse)</p>\n', 'hint': ''}, {'questionNo': 4, 'question': '<p>What is the error <strong>message</strong> returned?</p>\n', 'hint': ''}]}, {'taskTitle': 'Constant Variables', 'taskDesc': '<p></p><p></p><p><img style="width:25%;float:right" src="https://i.imgur.com/WjeAa62.png" class="note-float-right" />Rust also has constants. These are values that aren\'t just immutable by default, but are always immutable.</p>\n<p>Constants can be declared in any scope, including the global scope. This means that we can use their value in any part of our code, or in multiple places at once.</p>\n<p>Constants can only be constant, they cannot be set to a function call or any other value that may change at runtime.</p>\n<p>We declare constants with the <code>const</code> keyword like so:</p><p><code>const HUNDRED_THOUSAND: u32 = 100_000;</code></p>\n<p>Notice how in Rust, we can use the <code>_</code> character to denote a space in number without it affecting the value itself. This is purely for readability.</p>\n<p>Also note that it is tradition to name a constant in all uppercase.</p>\n<p><strong>Shadowing</strong></p>\n<p>I\'m going to show you something that might not make sense at first.</p>\n<code>fn main(){<br />\xa0\xa0 \xa0let x = 6;<br />\xa0\xa0 \xa0let x = x + 1;<br />\xa0\xa0 \xa0println!("{}", x)<br />}<br /></code><p></p><p>This is called <em>shadowing</em>. Rustaceans (Rust programmers) say that:</p>\n<p><i>"The first variable is shadowed by the second"</i></p>\n<p>Which means the second variables value appears when used. We can change the type of an immutable variable once it has been defined.<br /></p>\n<p>Here\'s an explanation from the official Rust docs about this principle (edited to match the example)</p>\n<p>"This program first binds x to a value of 6. Then it shadows x by repeating let x =, taking the original value and adding 1 so the value of x is then 7."</p>\n<p>By using let, we can perform transformations on the variable but have the variable still be immutable after all the transformations have completed.</p>\n<p>We\'re effectively creating a new variable with the <code>let</code> keyword, which means we can change the type of the value.</p>\n<p></p><p><code>let word = "hello";<br />let word = word.len();</code><br /></p><p></p><p>Which is allowed.</p>\n<p>However, if we tried to use mut, it wouldn\'t be allowed â€” as mut cannot change types.</p>\n<code>let mut word = "hello";<br />word = word.len();</code><p></p><p><code>error[E0308]: mismatched types<br />\xa0--&gt; src/main.rs:3:12<br />\xa0 |<br />3 |\xa0\xa0\xa0\xa0 word = word.len();<br />\xa0 |\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0 ^^^^^^^^^^ expected `&amp;str`, found `usize`</code><br /></p><p></p><p></p>', 'taskType': 'none', 'taskNo': 5, 'taskCreated': '2020-08-09T20:59:17.633Z', 'taskDeadline': None, 'tasksInfo': [], 'uploadId': '', 'questions': [{'questionNo': 1, 'question': 'I have read this task.<br />', 'hint': ''}, {'questionNo': 2, 'question': '<p>How do we define a constant in Rust?</p>', 'hint': ''}, {'questionNo': 3, 'question': '<p>Can we shadow a constant? T(rue) or F(alse)</p>', 'hint': ''}, {'questionNo': 4, 'question': '<p>What do we use to change the type of an immutable variable once it has been defined?</p>', 'hint': '"The first variable is <ANSWER> by the second".". adjective'}, {'questionNo': 5, 'question': '<p>Will the code "CONST word = "yes"" compile? T(rue) or F(alse)</p>', 'hint': ''}, {'questionNo': 6, 'question': '<p>We have "let word = "hello"", how do we get the length of the variable?</p>', 'hint': ''}]}, {'taskTitle': 'Data Structures', 'taskDesc': '<p></p><p><img style="width:25%;float:right" src="https://i.imgur.com/5Rjf52N.png" class="note-float-right" />In Rust we\'ll very often see the compiler complain that our variables and functions aren\'t type hinted. We saw type hints with <span style="font-family:&quot;SFMono-Regular&quot;, Consolas, &quot;Liberation Mono&quot;, Menlo, Courier, monospace;line-height:normal;background:rgba(135,131,120,0.15);color:#EB5757;border-radius:3px;font-size:85%;padding:0.2em 0.4em">CONST</span> earlier. A type hint defines what the data type of a variable is at compile time.</p><p><code>let ports: u32 = 65535<br /></code><br /></p>\n<p></p><p>The <code>: u32</code> states that the variable <code>ports</code> is of size <code>u32</code>.</p>\n<p>The <code>u</code> in the integer means unsigned, and the <code>32</code> is how many bits it has.</p>\n<p>Unsigned integers can only ever be positive, signed integers can be both positive and negative.</p>\n<p>Integers range from 16 bits up to 128 bits. Some operating systems can\'t use integers higher than u32, and using such large integer types may slow down the program on some systems.</p><table class="table table-bordered"><tbody><tr><td><b>8-bit<br /></b></td><td><b>i8<br /></b></td><td><b>u8<br /></b></td></tr><tr><td>16-bit<br /></td><td>i16<br /></td><td>u16<br /></td></tr><tr><td>32-bit<br /></td><td>i32<br /></td><td>u32<br /></td></tr><tr><td>64-bit<br /></td><td>i64<br /></td><td>u64<br /></td></tr><tr><td>128-bit<br /></td><td>i128<br /></td><td>u128<br /></td></tr><tr><td>arch<br /></td><td>isize<br /></td><td>usize<br /></td></tr></tbody></table><p>As you explore Rust, you will come across many, many different data types. It would be foolish for me to try and teach them all, so I have elected to teach only what I believe will help you understand Rust right now.</p>\n<p>We\'ve seen how integers work, but what about strings?</p>\n<h2>Strings</h2><p>There are two types of strings in Rust. <code>String</code> and <code>&amp;str</code>.</p>\n<p><code>String</code> is a growable allocated data structure whereas <code>str</code> is an immutable fixed-length string somewhere in memory.</p>\n<p><code>&amp;str</code> is a <code>string slice</code> of <code>string.</code></p>\n<p>Strings are confusing for beginners in Rust, but these are the core principles. <a href="https://doc.rust-lang.org/book/ch08-02-strings.html">Here\'s a list to the relevant Rust book page on Strings for more information.</a></p>\n\n', 'taskType': 'none', 'taskNo': 6, 'taskCreated': '2020-08-09T21:08:20.107Z', 'taskDeadline': None, 'tasksInfo': [], 'uploadId': '', 'questions': [{'questionNo': 1, 'question': 'Given the number -6, is this signed or unsigned?', 'hint': ''}, {'questionNo': 2, 'question': '<p>Given the number 65536, what is the smallest unsigned datatype we can fit this into?</p>', 'hint': ''}, {'questionNo': 3, 'question': "<p>What's the smallest sized signed integer in rust?</p>", 'hint': ''}, {'questionNo': 4, 'question': '<p>Create a mutable u32 variable called "tryhackme" and assign it the number 9</p>', 'hint': 'u32 data type'}, {'questionNo': 5, 'question': '<p>What data type is used to represent a string slice?</p>', 'hint': ''}, {'questionNo': 6, 'question': '<p>Let\'s say you had a variable, X. You wanted to typehint the variable as a string. What would you write? Include X in the variable but not the <span style="font-family:&quot;SFMono-Regular&quot;, Consolas, &quot;Liberation Mono&quot;, Menlo, Courier, monospace;line-height:normal;background:rgba(135,131,120,0.15);color:#EB5757;border-radius:3px;font-size:85%;padding:0.2em 0.4em">let</span> or <span style="font-family:&quot;SFMono-Regular&quot;, Consolas, &quot;Liberation Mono&quot;, Menlo, Courier, monospace;line-height:normal;background:rgba(135,131,120,0.15);color:#EB5757;border-radius:3px;font-size:85%;padding:0.2em 0.4em">=</span> parts.</p>', 'hint': ''}]}, {'taskTitle': 'Functions', 'taskDesc': '<p></p><p></p><p><img style="width:25%;float:right" src="https://i.imgur.com/ebEIiEw.png" class="note-float-right" /><br /></p><p>We\'ve already seen a special kind of function earlier, the <code>main</code> function.</p>\n<p>The <code>main</code> function is the first function called of the <code>main</code> file, which is the first file called.</p>\n<p>Every binary file written in Rust needs a <code>main</code> file, and every main file needs a <code>main</code> function.</p>\n<p>Functions in Rust are defined as:</p><p><code>fn hello() -&gt; u16{<br />\xa0\xa0\xa0 println!("hello!");<br />\xa0\xa0\xa0 6<br />}</code><br /></p>\n<p>The main function is the same as this, but in a binary file it doesn\'t return anything.</p><p><code>fn main(){<br />\xa0\xa0\xa0 println!("I do not return!")<br />}</code><br /></p><p>Now, you might have noticed in the <code>hello</code> function that we have a 6 on the end.</p><p><i>"What???"</i> I can hear you saying.<br /></p>\n<p></p><p>\n</p><p>Well, Rust returns the final expression of the function.</p>\n<p>Alternatively, we can use the <code>return</code> statement to return earlier. However, it\'s not very nice to use it to return the value at the end of the function â€” Rustaceans and Clippy will dislike that ðŸ˜¢</p>\n<p><code>6</code> is an expression that returns 6, so our <code>hello</code> function returns 6.</p>\n<p>Our main function does not return anything, which is the way it should be.</p>\n<p>Let\'s add some arguments to our functions.</p><p><code>fn print_name(name: String){<br />\xa0\xa0\xa0 println!("{}", name);<br />}</code><br /></p>\n<p>Our function arguments have to include the type of each argument.</p>\n<p>Now let\'s try to make this function return something.</p>\n<code>fn print_name(name: String) -&gt; u16{<br />\xa0\xa0 \xa0println!("{}", name);<br />\xa0\xa0 \xa06;<br />}</code><p></p><p>When we return data, we have to type hint the type of data that is being returned.</p>\n<p>This may seem annoying, but it makes writing clean code so much easier.</p>\n<p>Compare these two functions, one in Pythonic pseudocode and one in Rust. Note: we only have the definitions.</p>\n<p></p><p><code>def to_ip_address(ip):</code></p><p>Now in Rust:</p><p><code>fn to_ip_address(ip: String) -&gt; IpAddr{<br /></code><br /></p><p></p><p>By just adding the types we can clearly see we are taking in a string, and turning it into an IP address.</p>\n<p>With proper function naming and typehints, we can tell what most functions do just from their definitions. How\'s that for clean code ðŸ˜œ</p><p><b>Question 1</b></p><p><code>fn hello(){<br />\xa0\xa0\xa0 8172192: u16;<br />}</code><b><br /></b></p><p><b>Question 2</b></p><p><code>fn return(){<br />\xa0\xa0\xa0 6;<br />}</code><b><br /></b></p><p><b>Question 3</b></p><p><code>fn test(name) {<br />\xa0\xa0\xa0 println!("{}", name);<br />}<br />test("bee");</code><b><br /></b><br /></p>\n<p></p>', 'taskType': 'downloadable', 'taskNo': 7, 'taskCreated': '2020-08-09T21:21:19.090Z', 'taskDeadline': None, 'tasksInfo': [], 'uploadId': '5f306b4ba7ba177accd737c6', 'questions': [{'questionNo': 1, 'question': 'Will question 1 return 8172192? T(rue) or F(alse)', 'hint': ''}, {'questionNo': 2, 'question': '<p>Will example 2 run? T(rue) or F(alse)</p>', 'hint': ''}, {'questionNo': 3, 'question': '<p>What type should we give to the argument for question 3?<br /></p>', 'hint': '"bee" is passed to the test function which makes the argument a &\'static str'}, {'questionNo': 4, 'question': 'The last expression in a function (the return) needs to have a semicolon. T(rue) or F(alse)', 'hint': 'Since you can return values such as "42" without semicolons.'}, {'questionNo': 5, 'question': '<p>Every function need to return something. T(rue) or F(alse)</p>', 'hint': ''}, {'questionNo': 6, 'question': 'Functions in Rust can be nested within other functions. T(rue) or F(alse)', 'hint': ''}, {'questionNo': 7, 'question': '<p>What keyword do we use to return early from a function?<br /></p>', 'hint': ''}, {'questionNo': 8, 'question': '<p>You nest a function named main, inside another function named main. Will this run? T(rue) or F(alse)</p>', 'hint': ''}]}, {'taskTitle': 'Loops', 'taskDesc': '<p></p><p></p><p><img style="width:25%;float:right" src="https://i.imgur.com/bS8q45g.png" class="note-float-right" /><br /></p><p>There are 3 loops in Rust.</p><h2>loop</h2>\n<p>The <code>loop</code> keyword loops forever or until we explicitly tell it to stop.</p><p><code>fn main(){<br />\xa0\xa0\xa0 loop {<br />\xa0\xa0\xa0 \xa0\xa0\xa0 println!("TryHackMe Rocks!");<br />\xa0\xa0\xa0 }<br />}</code><br /></p>\n\n<p></p><p>We can either break with <span style="font-family:&quot;SFMono-Regular&quot;, Consolas, &quot;Liberation Mono&quot;, Menlo, Courier, monospace;line-height:normal;background:rgba(135,131,120,0.15);color:#EB5757;border-radius:3px;font-size:85%;padding:0.2em 0.4em">ctrl+c</span> or we can tell Rust to break with <span style="font-family:&quot;SFMono-Regular&quot;, Consolas, &quot;Liberation Mono&quot;, Menlo, Courier, monospace;line-height:normal;background:rgba(135,131,120,0.15);color:#EB5757;border-radius:3px;font-size:85%;padding:0.2em 0.4em">break</span></p><p><code>fn main(){<br />\xa0\xa0\xa0 loop {<br />\xa0\xa0\xa0 \xa0\xa0\xa0 println!("TryHackMe Rocks!");<br />\xa0\xa0\xa0 \xa0\xa0\xa0 break;<br />\xa0\xa0\xa0 }<br />}</code><br /></p><h2>Conditional While Loops</h2>\n<p>Rust also has while loops, which loop while a condition is true.</p>\n<p>Look at this example for some code, taken from the <a href="https://doc.rust-lang.org/book/ch03-05-control-flow.html">Rust Book</a>:</p><p><code>fn main() {<br />\xa0\xa0\xa0 let mut number = 3;<br /><br />\xa0\xa0\xa0 while number != 0 {<br />\xa0\xa0\xa0\xa0\xa0\xa0\xa0 println!("{}!", number);<br /><br />\xa0\xa0\xa0\xa0\xa0\xa0\xa0 number -= 1;<br />\xa0\xa0\xa0 }<br /><br />\xa0\xa0\xa0 println!("LIFTOFF!!!");<br />}</code><br /></p>\n<h2>For loops</h2>\n<p>Rust also has for loops, which we can use to iterate over elements of a collection.</p>\n<code>fn main() {<br />\xa0\xa0\xa0 let a = [10, 20, 30, 40, 50];<br /><br />\xa0\xa0\xa0 for element in a.iter() {<br />\xa0\xa0\xa0\xa0\xa0\xa0\xa0 println!("the value is: {}", element);<br />\xa0\xa0\xa0 }<br />}</code><p>Note the <span style="font-family:&quot;SFMono-Regular&quot;, Consolas, &quot;Liberation Mono&quot;, Menlo, Courier, monospace;line-height:normal;background:rgba(135,131,120,0.15);color:#EB5757;border-radius:3px;font-size:85%;padding:0.2em 0.4em">a.iter</span>. We turn <span style="font-family:&quot;SFMono-Regular&quot;, Consolas, &quot;Liberation Mono&quot;, Menlo, Courier, monospace;line-height:normal;background:rgba(135,131,120,0.15);color:#EB5757;border-radius:3px;font-size:85%;padding:0.2em 0.4em">a</span> into an iterable using this. This will become very important to us very soon.</p><p></p>', 'taskType': 'none', 'taskNo': 8, 'taskCreated': '2020-08-09T21:46:14.507Z', 'taskDeadline': None, 'tasksInfo': [], 'uploadId': '', 'questions': [{'questionNo': 1, 'question': 'How do we break out of a loop?', 'hint': ''}, {'questionNo': 2, 'question': '<p>Simplest keyword to make an infinite loop?</p>', 'hint': ''}, {'questionNo': 3, 'question': '<p>Turn <span style="font-family:&quot;SFMono-Regular&quot;, Consolas, &quot;Liberation Mono&quot;, Menlo, Courier, monospace;line-height:normal;background:rgba(135,131,120,0.15);color:#EB5757;border-radius:3px;font-size:85%;padding:0.2em 0.4em">let a = [10, 20];</span> into something we can iterate over.</p>', 'hint': ''}, {'questionNo': 4, 'question': '<p>While loops can also be infinite. T(rue) or F(alse).</p>', 'hint': ''}]}, {'taskTitle': 'Zero Cost Abstractions', 'taskDesc': '<p></p><p></p><p><img style="width:25%;float:right" src="https://i.imgur.com/pE3jJ8R.png" class="note-float-right" /><br /></p><p>This task is copied from my blog, where I wrote about <a href="https://bees.substack.com/p/vtubers-random-algorithms-constraints" target="_blank">Zero Cost Abstractions once</a>.</p><p>Rust has this really cool thing called Zero Cost Abstractions. Itâ€™s \nalso a thing in other low level languages, but being a Python Surfer \nDude I havenâ€™t come across it before. </p><p>Zero cost abstraction is:</p><blockquote><p><i>"What you donâ€™t use, you donâ€™t pay for. And what you do use, you couldnâ€™t do any better if you coded by hand."</i></p></blockquote><p>Letâ€™s talk about the 2 parts of this sentence.</p><blockquote><p><i>"What you donâ€™t use, you donâ€™t pay for."</i></p></blockquote><p>The\n language shouldnâ€™t have a global cost for a feature that isnâ€™t used. \nLetâ€™s say to use a for loop, the language needs to have some massive 1gb\n file that slows down everything else. If we never use a for loop, we \nstill pay for the for loop!</p><blockquote><p><i>"And what you do use, you couldnâ€™t do any better if you coded by hand."</i></p></blockquote><p>Hereâ€™s the kicker.</p><p>Say you wrote some code, a function that calculated Fibonacci numbers. And you compiled this code down into assembly.</p><p>Now letâ€™s say you hand-write assembly to do the same function â€” calculate Fibonacci numbers but this time in assembly. </p><p>Handwriting it in assembly would mean we would either gain no performance, or we would lose performance.</p><p>By\n using zero cost abstractions, we write abstracted code (not handwritten\n assembly) and we couldnâ€™t do any better if we tried to hand-write \nassembly. Now thatâ€™s cool!</p><p>Now, let\'s explore iterators. </p><p>Iterators are a way of processing a series of items with Rust, much like a for loop.</p><p>We saw earlier <code>a.iter()</code>. This code turns the variable <code>a</code> into an iterator over the items of <code>a</code>. But this code by itself doesn\'t do anything useful.</p>\n<p>This is because iterators are <em>lazy</em>. You have to tell them to do something to get values from them.</p>\n<p>Let\'s take a look at a real example.</p>\n<code>let a = vec![1, 2, 3];<br />let a_iter = a.iter();<br />for val in a_iter {<br />\xa0\xa0 \xa0println!("The value is {}, val);<br />}</code><p></p><p>We make the iterator do something by calling it in this for loop.</p>\n<p>Now we can make the code do something and <code>consume</code> the iter using some nifty functional programming skills. To square every number in an iterator, and then to sum it we can do:</p><p><code>let a = vec![1, 2, 3];<br />a.iter()<br />.map(|&amp;i| i * i<br />.sum()</code><br /></p>\n<p></p><p>Note, in Rust, we can separate applications of methods with new lines.</p>\n<p>This is just a small portion of what iterators can do. Read  the entire chapter on them from the <a href="https://doc.rust-lang.org/book/ch13-02-iterators.html#processing-a-series-of-items-with-iterators">Rust Book here</a>.</p>\n<p>However, let\'s get back to the important tasks at hand. Zero cost abstractions.</p>\n<p>Iterators are zero cost abstractions in Rust. For loops are not. This is according to the <a href="https://doc.rust-lang.org/book/ch13-04-performance.html">Rust Book.</a></p>\n<p>By using iterators, we are taking advantage of the fantastic zero cost abstraction. Speeding up our entire program.</p>\n', 'taskType': 'none', 'taskNo': 9, 'taskCreated': '2020-08-09T21:48:04.300Z', 'taskDeadline': None, 'tasksInfo': [], 'uploadId': '', 'questions': [{'questionNo': 1, 'question': 'Read the above.<br />', 'hint': ''}, {'questionNo': 2, 'question': '<p>Iterators are lazy. T(rue) or F(alse).</p>', 'hint': ''}, {'questionNo': 3, 'question': '<p>For loops are explicitly mentioned in the Rust book as zero cost abstractions. T(rue) or F(alse).</p>', 'hint': ''}, {'questionNo': 4, 'question': '<p>Zero Cost Abstractions are common in high level languages like Python or JavaScript T(rue) or F(alse).</p>', 'hint': ''}]}, {'taskTitle': 'Rayon', 'taskDesc': '<p></p><p><img style="width:25%;float:right" src="https://i.imgur.com/uytTr93.png" class="note-float-right" /><br /></p><p>Rayon is an external crate for Rust, and normally I wouldn\'t include external libraries. However, it\'s just so awesome and fits so well with the last few tasks I just had to mention it.</p><p>Rayon makes multi threading easy. No, really. It\'s extremely easy.</p><p>Go to <a href="https://crates.io/crates/rayon" target="_blank">Crates.io</a> and copy the big black box containing the crate with the version number.</p><p><img style="width:100%" src="https://i.imgur.com/F2Tpif3.png" />Now go into cargo.toml, and include it in the dependencies section. Just copy and paste it across.</p><p>Okay, now let\'s take our iter in the last task and make it multi threaded.</p><pre><code>fn sum_of_squares(input: &amp;[i32]) -&gt; i32 {<br />\xa0\xa0\xa0 input.iter()<br />\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0 .map(|&amp;i| i * i)<br />\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0 .sum()<br />}<br /></code><span></span></pre>\n<p></p><p>This is our previous code.</p><p><code>use rayon::prelude::*;<br />fn sum_of_squares(input: &amp;[i32]) -&gt; i32 {<br />\xa0\xa0\xa0 input.par_iter() // &lt;-- just change that!<br />\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0 .map(|&amp;i| i * i)<br />\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0 .sum()<br />}</code><br /></p><p>This is our multi-threaded code.<br /></p><p>Look at how easy that is! We change iter() into par_iter() and we\'re done. We\'re now multi threaded.<br /></p>', 'taskType': 'none', 'taskNo': 10, 'taskCreated': '2020-08-09T21:48:24.427Z', 'taskDeadline': None, 'tasksInfo': [], 'uploadId': '', 'questions': [{'questionNo': 1, 'question': 'What crate do we use to easily make an iter multi threaded?<br />', 'hint': ''}, {'questionNo': 2, 'question': '<p>How do we tell Rust to include an external crate into our program? <b>What file do we place this information in?</b><br /></p>', 'hint': ''}, {'questionNo': 3, 'question': '<p>Turn a.iter() into a multi threaded parallel iter using Rayon<br /></p>', 'hint': ''}, {'questionNo': 4, 'question': '<p>What website do we go to for Crates?<br /></p>', 'hint': ''}]}, {'taskTitle': 'If Statements', 'taskDesc': '<br /><p><img style="width:25%;float:right" src="https://i.imgur.com/1blPR00.png" class="note-float-right" />If statements work exactly like how you\'d expect.</p><p><code>let var =\xa0 6;<br />if var == 6{<br />\xa0\xa0\xa0 println!("oh no the var is 6");<br />}<br />else {<br />\xa0\xa0\xa0 println!("yay the var isn\'t 6");<br />}</code><br /></p><p>But, Rust lets us do cool things with if statements. Such as assigning to a variable based on an if statement.<code>fn func() -&gt; i8{<br />9<br />}<br /><br />let var = 6 + func();<br /><br />let result = if var == 6 {15} else {200};<br />let output =<br />if var == 15 {<br />\xa0\xa0\xa0 println!("it is 15");<br />\xa0\xa0\xa0 9;<br />}else {<br />\xa0\xa0\xa0 println!("it is not 15");<br />\xa0\xa0\xa0 10;<br />};</code></p><p>And that\'s it. Nothing really to it, it\'s exactly like every other language.</p><p><br /></p>', 'taskType': 'none', 'taskNo': 11, 'taskCreated': '2020-08-09T21:48:38.940Z', 'taskDeadline': None, 'tasksInfo': [], 'uploadId': '', 'questions': [{'questionNo': 1, 'question': 'We can assign variables based on an if statement on one line T(rue) or F(alse)', 'hint': ''}]}, {'taskTitle': 'Error Handling', 'taskDesc': '<br /><p><img style="width:25%;float:right" src="https://i.imgur.com/57mUxJQ.png" class="note-float-right" />Now we get into the inner-workings of Rust, the thing that helps keep it safe. Error handling.</p>\n<p>In Rust, anything that <em>can</em> error will return a result. Specifically <code>Result&lt;T, E&gt;</code>. <code>T</code> is the result you are looking for, <code>E</code> is the error.</p><p><code>enum Result&lt;T, E&gt; {<br />\xa0\xa0\xa0 Ok(T),<br />\xa0\xa0\xa0 Err(E),<br />}<br /></code><br /></p><p>Anytime\n you open a file, the file might not be there or it may fail to open the\n file successfully. It will return a Result, and you will have to deal \nwith it that way.</p>\n<p>In Python, exception handling is given to the user. If you want to \nopen a file, go ahead. But don\'t forget to write an exception for if the\n file isn\'t there!</p>\n<p>But in Rust, no matter what (unless you explicitly tell the compiler to ignore it) errors must be handled.</p>\n<p>Let\'s look at an example.</p><p><code>use std::fs::File;<br /><br />fn main() {<br />\xa0\xa0\xa0 let f = File::open("hello.txt");<br />}<br /></code><br /></p>\n<p>Here we go to open a file. The file isn\'t stored in f, what is stored is actually a Result enum.</p>\n<p>There are 2 ways to check if something returns an result.</p>\n<ol><li>Rust Analyzer will tell us what the return type is.</li><li>We assign a type we know is wrong, and the compiler will tell us.</li></ol>\n<p>If we assigned <code>let f: u32 = File::open("hello.txt");</code> the compiler will tell us.</p>\n<code>--&gt; src/main.rs:4:18<br />\xa0 |<br />4 |\xa0\xa0\xa0\xa0 let f: u32 = File::open("hello.txt");<br />\xa0 |\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0 ---\xa0\xa0 ^^^^^^^^^^^^^^^^^^^^^^^ expected `u32`, found enum `std::result::Result`<br />\xa0 |\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0 |<br />\xa0 |\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0 expected due to this<br />\xa0 |<br />\xa0 = note: expected type `u32`<br />\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0 found enum `std::result::Result&lt;std::fs::File, std::io::Error&gt;`</code><p><br /></p><p>So now we know that we have to handle the error, but the question is <em>how.</em></p>\n<p>I\'m going to show you 3 ways.</p>1. Unwrap\n<p>Unwrap is the easiest to implement. It tells Rust "I\'m \npretty sure this won\'t fail so just go ahead and take the value". If it \ndoes fail, well, Rust panics!</p>\n<code>use std::fs::File;<br /><br />fn main() {<br />\xa0\xa0\xa0 let f = File::open("hello.txt").unwrap();<br />}</code><p>2. Match</p>\n<p>Match is how you\'d expect this to work, if you\'re used to Python.</p>\n<p>We do one thing for an Ok, and we do another for an Error.</p>\n<code>use std::fs::File;<br /><br />fn main() {<br />\xa0\xa0\xa0 let f = File::open("hello);<br />\xa0\xa0 \xa0match f {<br />\xa0\xa0 \xa0\xa0\xa0 \xa0Ok(file) =&gt; file,<br />\xa0\xa0 \xa0\xa0\xa0 \xa0Err(_) =&gt; panic!("Couldn\'t open file."),<br />\xa0\xa0 \xa0}<br />}</code><p>If the result is <code>Ok</code>, that means the result is successful and we can just take the file.</p>\n<p>If it\'s an <code>Err</code> that means an error occurred and we need to do something about it. In this case, the program panics.</p>\n<p>3. ?<br /></p><p>\n</p><p>The ? operator states "if the result is Ok, carry on in this \nfunction. Else if it is an Err, propagate it back up the stack to the \nfunction that called me. "</p>\n<p>To illustrate this, let\'s look at this example I took from a <a href="https://doc.rust-lang.org/edition-guide/rust-2018/error-handling-and-panics/the-question-mark-operator-for-easier-error-handling.html">Rust blog post</a>.</p>\n<code>fn read_username_from_file() -&gt; Result&lt;String, io::Error&gt; {<br />\xa0\xa0\xa0 let f = File::open("username.txt");<br /><br />\xa0\xa0\xa0 let mut f = match f {<br />\xa0\xa0\xa0\xa0\xa0\xa0\xa0 Ok(file) =&gt; file,<br />\xa0\xa0\xa0\xa0\xa0\xa0\xa0 Err(e) =&gt; return Err(e),<br />\xa0\xa0\xa0 };<br /><br />\xa0\xa0\xa0 let mut s = String::new();<br /><br />\xa0\xa0\xa0 match f.read_to_string(&amp;mut s) {<br />\xa0\xa0\xa0\xa0\xa0\xa0\xa0 Ok(_) =&gt; Ok(s),<br />\xa0\xa0\xa0\xa0\xa0\xa0\xa0 Err(e) =&gt; Err(e),<br />\xa0\xa0\xa0 }<br />}</code><p>We\n have 2 matches in this code. A bit unruly. Ideally if we fail to open \nthe file, or fail to read to string we propagate a single error back up \nthe stack saying that this function failed.</p>\n<p>If it didn\'t, we should return the Ok result. That way, the function that called us will receive a <code>Result</code> type that it can more easily handle, and without us dealing with multiple <code>match</code> statements.</p>\n<code>fn read_username_from_file() -&gt; Result&lt;String, io::Error&gt; {<br />\xa0\xa0\xa0 let mut f = File::open("username.txt")?;<br />\xa0\xa0\xa0 let mut s = String::new();<br /><br />\xa0\xa0\xa0 f.read_to_string(&amp;mut s)?;<br /><br />\xa0\xa0\xa0 Ok(s)<br />}</code><h2>Conclusion</h2>\n<p>This is one of the most important concepts in Rust. Errors normally \ndo not happen, because every error has to be dealt with in some way. \nThis helps keep your code safe.</p>\n', 'taskType': 'none', 'taskNo': 12, 'taskCreated': '2020-08-09T23:50:04.431Z', 'taskDeadline': None, 'tasksInfo': [], 'uploadId': '', 'questions': [{'questionNo': 1, 'question': 'What is the data type returned from opening a file?', 'hint': ''}, {'questionNo': 2, 'question': '<p>Write the datatype of a generic Result with type hints</p>', 'hint': 'Due to XSS protection, the answer replaces the "<" with a space.'}, {'questionNo': 3, 'question': "<p>We're in a function and we get given a Result enum. If the Result is \nokay we want to continue working on it in this function. If the result \nis Err we want to return to the parent function with Err. What should we\n use?</p>", 'hint': ''}, {'questionNo': 4, 'question': "<p>We're certain our result will always return Ok, what should we use?</p>", 'hint': 'no ()'}]}, {'taskTitle': 'Challenge', 'taskDesc': '<p>Challenge file 1.</p><p>"M3I6r2IbMzq9" is the text.<br /></p><p>The text is encrypted with:</p><p>plaintext -&gt; ROT13 -&gt; base64 -&gt; rot13<br /></p><p>Go the opposite way and decrypt the file.</p><p>rot13 -&gt; base64 -&gt; ROT13 -&gt; plaintext</p><p>You\'ll notice it\'s the same order either way, so you don\'t have to worry about order. Just make sure ROT13 is on the inside. </p><p>You might run into lifetime borrow checker issues.</p><p>Here\'s some hints in case you do:</p><p>1. Google is your friend.</p><p>2. <a href="https://doc.rust-lang.org/book/ch04-02-references-and-borrowing.html" target="_blank">https://doc.rust-lang.org/book/ch04-02-references-and-borrowing.html</a><br /></p><p>3.\n Stop trying to do so many things at once. Break it down to the bare \nnecessities and slowly build back up to see what causes the errors. </p>', 'taskType': 'downloadable', 'taskNo': 13, 'taskCreated': '2020-08-09T21:48:48.098Z', 'taskDeadline': None, 'tasksInfo': [], 'uploadId': '5f371450fe806f4c1bf5e401', 'questions': [{'questionNo': 1, 'question': 'Challenge 1<br />', 'hint': ''}]}, {'taskTitle': 'Conclusion', 'taskDesc': '<p>And that\'s it! Rust is an extremely cool language, quite safe and very fast. But, there is one major tradeoff we have to make.</p><p><b>Rust does not support inheritance</b>. That means we have to individually implement behaviour for each data type we create. </p><p>However, this is also an advantage for security reasons. As it gives us time to think about what we are doing. We might want different hashing algorithms for employees in different departments, for example.<br /></p><p>If you want to write unsafe Rust, <a href="https://doc.rust-lang.org/book/ch19-01-unsafe-rust.html" target="_blank">check out this part of the Rust book</a>. I didn\'t talk about this in the room as unsafe Rust is, by nature, unsafe and not very well suited to blue team operations.</p><p>I\'m going to share with you some cool resources on Rust.</p><ul><li><a href="https://skerritt.blog/packaging-your-rust-package/" target="_blank">I\n wrote a blog post about packaging Rust apps for multiple systems here. \nSo if you ever want to distribute for Arch, Homebrew, Debian or more \nclick here.</a></li><li><a href="https://www.rust-lang.org/community" target="_blank">A link to Rust community, which contains a link to their official Discord where they discuss the language itself.</a></li><li><a href="http://reddit.com/r/rust/" target="_blank">The Rust subreddit</a></li><li><a href="https://zaiste.net/posts/shell-commands-rust/" target="_blank">Cool Rust CLI alternatives to popular commands</a></li><li><a class="anchor-3Z-8Bb anchorUnderlineOnHover-2ESHQB" href="https://github.com/rust-unofficial/awesome-rust" target="_blank">https://github.com/rust-unofficial/awesome-rust</a></li><li><a class="anchor-3Z-8Bb anchorUnderlineOnHover-2ESHQB" href="https://github.com/ctjhoa/rust-learning" target="_blank">https://github.com/ctjhoa/rust-learning</a><br /><br /><br /></li></ul>', 'taskType': 'none', 'taskNo': 14, 'taskCreated': '2020-08-10T00:01:17.445Z', 'taskDeadline': None, 'tasksInfo': [], 'uploadId': '', 'questions': [{'questionNo': 1, 'question': 'Goodbye! &lt;3<br />', 'hint': ''}]}]}