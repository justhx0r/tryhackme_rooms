{'image': 'https://tryhackme-images.s3.amazonaws.com/room-icons/0f8c6039ad037f3a19a394be967b81f6.png', 'title': 'JVM Reverse Engineering', 'description': 'Learn Reverse Engineering for Java Virtual Machine bytecode', 'code': 'jvmreverseengineering', 'users': 1867, 'tags': ['reverse engineering', 'java', 'bytecode', 'asm', 'jvm'], 'type': 'challenge', 'difficulty': 'medium', 'userCompleted': False, 'upVotes': 95, 'created': '2020-05-17T19:47:44.059Z', 'published': '2020-05-17T18:59:12.324Z', 'freeToUse': True, 'businessOnly': False, 'headerImage': 'https://i.imgur.com/kow1dpO.png', 'creator': 'cookiedragon234', 'tasks': [{'taskTitle': 'Introduction', 'taskDesc': '<p><span style="font-size:1rem">When java applications are compiled, they are turned into an intermediary form of machine code, known as bytecode. While java source code is designed to be easy for humans to read, bytecode is designed to be easy for machines to read.</span></p><p>When you execute a compiled java application the class file is read and interpreted by a Java Virtual Machine. This is like a custom virtual CPU that runs inside your existing CPU and follows a different instruction set, the JVM instruction set.</p><p>Java Bytecode is a stack based language. This means that temporary variables are stored in the stack, rather than how x86 stores in registers. Stacks are like buckets. When you add a variable to the stack, you put it at the top of the bucket. When you remove/use a variable from the stack you use the variable at the top of the stack. If you attempt to retrieve a variable from an empty stack this is known as a Stack Underflow. If you add too many variables such that the stack reaches its memory limit, this is known as a Stack Overflow (Think of a bucket overflowing from too many items).</p><p>The java bytecode to print "Hello World" to console is shown below:</p><p><code>getstatic java/lang/System.out:Ljava/io/PrintStream; // Retrieve the static variable "out" in the System class and store it on the stack</code></p><p><code>ldc "Hello World" // Load the string "Hello World" onto the stack</code></p><p><code>invokevirtual java/io/PrintStream.println:(Ljava/lang/String;)V // Invoke the "println" function on the System.out variable using the string at the top of the stack as an argument<br /></code>\xa0</p><p>For more information on the JVM instruction set I highly recommend\xa0<a href="https://en.wikipedia.org/wiki/Java_bytecode_instruction_listings">https://en.wikipedia.org/wiki/Java_bytecode_instruction_listings</a>.</p><p><br /></p><p>Because JVM Bytecode is a high level representation of the original source code, constructs such as methods, fields and classes are still visible.</p><p>Classes are compiled into .class files, one class per file. These can reference other classes which will be linked by the JVM at runtime. By using a parser such as javap we are able to see the methods and fields present in a class. Each will have a name and a descriptor. The descriptor is a representation of the arguments and return type a method can take, or the type of a field.</p><p>The following method:</p><p><code>void main(String[] args, int i)</code></p><p>would produce this descriptor and name:</p><p><code>main([Ljava/lang/String;I)V</code></p><p>The args are surrounded in brackets. A <code>[</code> brace represents an array. An object is represented by a fully qualified internal name prepended by an <code>L</code> and appended by an <code>;</code>. The <code>I</code> represents an Int, and the <code>V</code> at the end represents the type void. A full writeup on descriptors can be seen here:\xa0<a href="https://docs.oracle.com/javase/specs/jvms/se7/html/jvms-4.html#jvms-4.3">https://docs.oracle.com/javase/specs/jvms/se7/html/jvms-4.html#jvms-4.3</a>.</p><p><br /></p><p>Javap is a tool bundled with JDK releases that can disassemble compiled classes. Example usage:</p><p>(p = show private members, v = verbose)</p><p><code>javap -v -p HelloWorld.class</code><br /></p>', 'taskType': 'none', 'taskNo': 1, 'taskCreated': '2020-03-12T22:37:13.551Z', 'taskDeadline': None, 'tasksInfo': [], 'uploadId': '', 'questions': [{'questionNo': 1, 'question': '<p>Read the above text</p>', 'hint': ''}, {'questionNo': 2, 'question': '<p>Consider the following bytecode:</p><p>LDC 0</p><p>LDC 3</p><p>SWAP</p><p>POP</p><p>INEG</p><p>Which value is now at the top of the stack?</p>', 'hint': ''}, {'questionNo': 3, 'question': '<p>Which opcode is used to get the XOR of two longs? (answer in lowercase)</p>', 'hint': ''}, {'questionNo': 4, 'question': '<p>What does the -v flag on javap stand for?<span style="font-size:1rem">\xa0</span><span style="font-size:1rem">(answer in lowercase)</span></p>', 'hint': ''}]}, {'taskTitle': 'Simple Hello World', 'taskDesc': '<p>Complete the follow challenges.</p>', 'taskType': 'downloadable', 'taskNo': 2, 'taskCreated': '2020-03-12T19:55:49.843Z', 'taskDeadline': None, 'tasksInfo': [], 'uploadId': '5e6a937866f4757f66fdf423', 'questions': [{'questionNo': 1, 'question': '<p>Find the name of the file that this class was compiled from (AKA Source File)</p>', 'hint': 'Javap is a useful tool to find information about compiled classes'}, {'questionNo': 2, 'question': '<p>What is the super class of the Main class? (Using internal name format, i.e. /)</p>', 'hint': 'Adding flags like -c to javap allow you to see the bytecode of methods.\n\nThe constructor of a method always calls the constructor of its super class'}, {'questionNo': 3, 'question': '<p>What is the value of the local variable in slot 1 when the method returns? (In decimal format)<br /></p>', 'hint': ''}]}, {'taskTitle': 'Cracking a password protected application', 'taskDesc': '<p>The given class file takes a password as a parameter. You need to find the correct one. Tools like javap will be sufficient.</p>', 'taskType': 'downloadable', 'taskNo': 3, 'taskCreated': '2020-03-12T20:13:18.016Z', 'taskDeadline': None, 'tasksInfo': [], 'uploadId': '5e6a971ef77bd159be3f36f3', 'questions': [{'questionNo': 1, 'question': '<p>What is the correct password</p>', 'hint': 'The -v tag on javap will print the constant pool, containing utf8 encoded strings'}]}, {'taskTitle': 'Basic String Obfuscation', 'taskDesc': '<p>Like the previous task, this program takes a password as an argument, and outputs whether or not it is correct. This time the string is not directly present in the class file, and you will need to use either a decompiler, bytecode analysis or virtualisation to find it.</p>', 'taskType': 'downloadable', 'taskNo': 4, 'taskCreated': '2020-03-12T20:23:42.484Z', 'taskDeadline': None, 'tasksInfo': [], 'uploadId': '5e6a99b16b8a9a67851d7d75', 'questions': [{'questionNo': 1, 'question': '<p>What is the correct password?</p>', 'hint': 'You will need to use either a decompiler, bytecode analysis or virtualisation to find it.'}]}, {'taskTitle': 'Advanced bytecode manipulation', 'taskDesc': '<p><a href="https://asm.ow2.io/" target="_blank">ASM </a>is a powerful open source library for manipulating bytecode. It gives a high level representation of bytecode that is easy to parse and modify.</p><p>You can use asm to programmatically remove obfuscation in java applications.\xa0<a href="https://github.com/java-deobfuscator/deobfuscator" target="_blank">Java Deobfuscator</a>\xa0is an open source project that aims to use ASM to remove common obfuscation. They provide already implemented transformers, as well as the ability to make your own. A simple way to solve advanced crackmes like the one below is to virtualise method calls, for example the method calls to decrypt the strings. Java deobfuscator provides the necessary tools to do this, and there are prewritten examples that you can adapt to any program.</p>', 'taskType': 'none', 'taskNo': 5, 'taskCreated': '2020-03-13T08:21:02.891Z', 'taskDeadline': None, 'tasksInfo': [], 'uploadId': '', 'questions': [{'questionNo': 1, 'question': '<p>Read the above</p>', 'hint': ''}]}, {'taskTitle': 'Advanced String Obfuscation', 'taskDesc': '<p>This program follows the same logic as the previous task, however it has a custom obfuscation layered on top. You might require a decompiler for this, as well as custom tools. This uses anti virtualisation techniques as well, so be warned.</p>', 'taskType': 'downloadable', 'taskNo': 6, 'taskCreated': '2020-03-12T21:16:32.602Z', 'taskDeadline': None, 'tasksInfo': [], 'uploadId': '5e6aa1ba66f4757f66fdf7d3', 'questions': [{'questionNo': 1, 'question': '<p>Find the correct password</p>', 'hint': 'You will either need to statically reverse engineer the string deobfuscation functions or use some kind of custom made virtualisation tool'}]}, {'taskTitle': 'Extreme Obf', 'taskDesc': '<p>This final jar has nearly every exploit I know packed into it. I dont know of any decompilers that will work for it. You will have to use custom tools and bytecode analysis to pick apart this one.</p><p>Same format as the previous tasks, takes one argument as the password.</p>', 'taskType': 'downloadable', 'taskNo': 7, 'taskCreated': '2020-03-12T21:34:41.568Z', 'taskDeadline': None, 'tasksInfo': [], 'uploadId': '5e6aaa752763ba46ff60982c', 'questions': [{'questionNo': 1, 'question': '<p>What is the correct password?</p>', 'hint': 'You will need custom tools for this one! Feel free to ask mastercooker#7021 on discord for help.'}]}]}