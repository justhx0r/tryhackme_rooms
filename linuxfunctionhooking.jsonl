{'image': 'https://tryhackme-images.s3.amazonaws.com/room-icons/c0911c9d569c72aa687d73dce22a450a.png', 'title': 'Linux Function Hooking', 'description': 'Learn about function hooking in Linux and have fun hooking functions', 'code': 'linuxfunctionhooking', 'users': 2919, 'tags': ['security', 'c programming', 'linux', 'LD_PRELOAD'], 'type': 'walkthrough', 'difficulty': 'medium', 'userCompleted': False, 'upVotes': 230, 'created': '2021-06-03T09:33:34.022Z', 'published': '2021-07-13T19:00:00.706Z', 'freeToUse': True, 'businessOnly': False, 'headerImage': 'https://assets.tryhackme.com/img/banners/default_tryhackme.png', 'creator': 'whokilleddb', 'tasks': [{'taskTitle': 'Introduction', 'taskDesc': 'In this room, we will be looking into what are <b><i>Shared Libraries</i></b>, what is <b><i>Function Hooking</i></b> and how we can leverage <b><i>LD_PRELOAD</i></b> to do the same! I have tried to keep this room as simple as possible, however some basic understanding of C will be definitely useful!', 'taskType': 'none', 'taskNo': 1, 'taskCreated': '2021-06-03T09:37:31.296Z', 'taskDeadline': None, 'tasksInfo': [], 'uploadId': '', 'questions': [{'questionNo': 1, 'question': 'I am ready to learn!', 'hint': ''}]}, {'taskTitle': 'What are Shared Libraries?', 'taskDesc': '<div><span style="font-size:24px"><b>What Are Shared Libraries?</b></span></div><div><span style="font-size:1rem"><br /></span></div><div><span style="font-size:1rem">Shared libraries are pre-compiled C-code that are linked during the final steps of producing an executable. They provide reusable features like functions, routines, classes, data structures, etc., which can then be used while writing your own code.</span></div><div><span style="font-size:1rem"><br /></span></div><div>Common Shared Libraries which\xa0 Linux Contains are :</div><ul><li><b>libc</b> : The standard C library.</li><li><b>glibc</b> : GNU Implementation of standard <b>libc</b>.</li><li><b>libcurl </b>: Multiprotocol file transfer library.</li><li><b>libcrypt</b> : C Library to facilitate encryption, hashing, encoding etc.</li></ul><p>The important thing to know about shared libraries is that they contain the addresses of various functions required by programs during runtime.\xa0</p><p>For example, when a dynamically linked executable issues a <code>read()</code> syscall, the system looks up the address of <code>read()</code><span style="background-color:rgb(247, 247, 247)"></span> from the <b>libc</b> shared library. Now, <b>libc </b>has a well-defined definition for <code>read()</code>, which specifies the number and type of function parameters and expects a particular type of data in return. Usually, the system knows where to look for these functions, but as we will see later, we can control where the system looks for these functions and how we can leverage them for malicious purposes.</p><div><b>TL;DR</b>: Shared Libraries are compiled C code that contains function definitions which can be later called to perform certain functions. When we run dynamically linked executables, the system looks up the definitions of common functions in these libraries.</div><div><br /></div><p><span style="font-size:1rem">There is a lot that can be said about shared libraries at this point. However, I don\'t want to make this too difficult for people and want to keep it beginner-friendly, but I definitely encourage people to read more about these!</span><br /></p>', 'taskType': 'none', 'taskNo': 2, 'taskCreated': '2021-06-03T09:41:42.857Z', 'taskDeadline': None, 'tasksInfo': [], 'uploadId': '', 'questions': [{'questionNo': 1, 'question': 'What is the name of the dynamic linker/loader on linux?', 'hint': 'man page'}]}, {'taskTitle': 'Getting A Tad Bit Technical', 'taskDesc': '<p></p><p></p><p><span style="font-family:Ubuntu">\ufeff</span><span style="font-family:Ubuntu"></span>This section will be a tad bit technical, so bear with me for a while. Take a break and have some coffee and once you are ready, head on:</p><p><span style="font-size:1rem">So far we have learned that :</span></p><ol><li>When we execute a dynamically linked executable, it issues calls to certain standard functions which are predefined in shared libraries.</li><li>The system looks up the address of the function in the shared libraries.</li><li>The system returns the address of the <b>first</b> instance of the function as located in the shared library.</li><li>It then performs the required actions.</li></ol><p>Seems simple enough? Now let\'s get into the details. A large part of what\'s coming has been taken from the man page of<b> </b><code>ld.so</code><b>, </b>so\xa0it\'ll be helpful to have it handy.</p><p>With that out of the way, let\'s go on:</p><p>First, let\'s check the dynamically linked libraries needed by the <code>ls</code> command. To do this, you can type:</p><p><code style="font-size:14px"># ldd `which ls`</code></p>Or if you are using fish shell then:<p></p><p><code style="font-size:14px"># ldd (which ls)</code></p><p><span style="font-size:1rem">Either way, it should give you an output similar to this:\xa0</span></p><p><code># ldd /bin/ls\t\xa0 \xa0 \xa0 \xa0 <br />\xa0 \xa0 \xa0 \xa0 \xa0linux-gate.so.1 (0xb7f54000)\t\xa0 \xa0 \xa0 \xa0 <br />\xa0 \xa0 \xa0 \xa0 \xa0libselinux.so.1 =&gt; /lib/i386-linux-gnu/libselinux.so.1 (0xb7ed7000)\t\xa0 \xa0 \xa0 \xa0 <br />\xa0 \xa0 \xa0 \xa0 \xa0libc.so.6 =&gt; /lib/i386-linux-gnu/libc.so.6 (0xb7cf9000)\xa0 \xa0 \xa0 \xa0 \xa0<br />\xa0 \xa0 \xa0 \xa0 \xa0libdl.so.2 =&gt; /lib/i386-linux-gnu/libdl.so.2 (0xb7cf3000)<br />\xa0 \xa0 \xa0 \xa0 \xa0libpcre.so.3 =&gt; /lib/i386-linux-gnu/libpcre.so.3 (0xb7c7a000)<br />\xa0 \xa0 \xa0 \xa0 \xa0/lib/ld-linux.so.2 (0xb7f56000)<br />\xa0 \xa0 \xa0 \xa0 \xa0libpthread.so.0 =&gt; /lib/i386-linux-gnu/libpthread.so.0 (0xb7c59000)</code></p><p><span style="color:rgb(196, 20, 20);font-family:Ubuntu;font-size:14px"></span></p><p><i>Note: This example was taken from an x86 Kali System, on a 64-bit system we will have different locations and libraries.</i></p><p>Here, we find a library with the <b>soname\xa0</b><code>libc.so.6</code><span style="background-color:rgb(234, 234, 237);color:rgb(196, 20, 20);font-family:SFMono-Regular, Menlo, Monaco, Consolas, &quot;Liberation Mono&quot;, &quot;Courier New&quot;, monospace;font-size:14px"></span><span style="font-size:1rem">\xa0which is located at\xa0</span><code>/lib/i386-linux-gnu/libc.so.6</code><span style="background-color:rgb(234, 234, 237);color:rgb(196, 20, 20);font-family:SFMono-Regular, Menlo, Monaco, Consolas, &quot;Liberation Mono&quot;, &quot;Courier New&quot;, monospace;font-size:14px"></span><span style="font-size:1rem">. <br /><i>Note: These are just symbolic links to the real shared library files located somewhere else in the system.</i></span></p><p>Our main objective here is to understand how the system\'s dynamic linker loads these dynamic libraries during launching a program. For this, we will heavily refer to the\xa0<code>ld.so</code> man page.</p><p>In the man page, we find the following texts:</p><ul><li><i>Using the directories specified in the <b>DT_RPATH</b> dynamic section<span style="font-size:1rem">\xa0attribute of the binary if\xa0 present\xa0 and\xa0 <b>DT_RUNPATH\xa0</b> attribute\xa0</span><span style="font-size:1rem">does not exist.\xa0 Use of <b>DT_RPATH</b> is deprecated.</span></i></li><li><i>Using the environment variable <b>LD_LIBRARY_PATH</b>, unless the exe<span style="font-size:1rem">cutable is being run in secure-execution mode (see\xa0 below),\xa0 in\xa0</span><span style="font-size:1rem">which case this variable is ignored.</span></i></li><li><i>Using\xa0 the directories specified in the <b>DT_RUNPATH</b> dynamic sec<span style="font-size:1rem">tion attribute of the binary if present.\xa0 Such directories\xa0 are\xa0</span><span style="font-size:1rem">searched\xa0 only to find those objects required by <b>DT_NEEDED</b> (di</span><span style="font-size:1rem">rect dependencies) entries and do not apply to\xa0 those\xa0 objects\'</span><span style="font-size:1rem">\xa0children,\xa0 which\xa0 must themselves have their own <b>DT_RUNPATH</b> en</span><span style="font-size:1rem">tries.\xa0 This is unlike <b>DT_RPATH</b>, which is applied\xa0 to\xa0 searches</span><span style="font-size:1rem">\xa0 for all children in the dependency tree.</span></i></li><li><i><span style="font-size:1rem">From the cache file <b>/etc/ld.so.cache</b>, which contains a compiled</span><span style="font-size:1rem">\xa0list of candidate shared objects previously found in\xa0 the\xa0 aug</span><span style="font-size:1rem">mented\xa0 library\xa0 path.\xa0 If, however, the binary was linked with</span><span style="font-size:1rem">\xa0the<b> -z nodeflib</b> linker option, shared objects in the default</span><span style="font-size:1rem">\xa0paths are skipped.\xa0 Shared objects installed in hardware capa</span><span style="font-size:1rem">bility directories (see below) are preferred to other\xa0 shared\xa0</span><span style="font-size:1rem">objects.</span><br /></i></li><li><i>In\xa0 the\xa0 default path <b>/lib</b>, and then <b>/usr/lib</b>.\xa0 (On some 64-bit\xa0<span style="font-size:1rem">\xa0 architectures, the default paths for 64-bit shared objects\xa0 are</span><span style="font-size:1rem">\xa0<b>/lib64</b>,\xa0 and\xa0 then\xa0 <b>/usr/lib64</b>.)\xa0 If the binary was linked with</span><span style="font-size:1rem">\xa0the <b>-z nodeflib</b> linker option, this step is skipped.</span></i></li></ul><p>Yes, this part might be a tad bit complicated, don\'t sweat over it. Just know that there are some Environment Variables and System Paths where the dynamic linker looks for these shared libraries while running programs.</p><p>The part which interests us lies a bit below under the <b>LD_PRELOAD</b> section. I encourage everyone to read the entire section (it\'s relatively short as well). The part which we should be paying attention to are the bullet points at the end of the section (especially the first and last ones) :</p><p><i>\xa0 \xa0 \xa0 \xa0 \xa0 \xa0 \xa0 (1) The <b>LD_PRELOAD</b> environment variable.</i></p><p><i>\xa0 \xa0 \xa0 \xa0 \xa0 \xa0 \xa0 (2) The <b>--preload</b> command-line option when invoking the dynamic linker directly.</i></p><p><i>\xa0 \xa0 \xa0 \xa0 \xa0 \xa0 \xa0 (3) The <b>/etc/ld.so.preload</b> file.</i></p><p>We are more interested in points <i>(1)</i> and <i>(3)</i> as they let us specify our own shared objects which are loaded<i>\xa0BEFORE\xa0</i>\xa0other shared libraries, and much like similar PATH hijacking attacks, we are going to use these to create our very own malicious shared libraries!</p><p></p>', 'taskType': 'none', 'taskNo': 3, 'taskCreated': '2021-06-03T10:40:18.447Z', 'taskDeadline': None, 'tasksInfo': [], 'uploadId': '', 'questions': [{'questionNo': 1, 'question': "What environment variable let's you load your own shared library before all others?\xa0", 'hint': ''}, {'questionNo': 2, 'question': '<p>Which f<span style="font-size:1rem">ile contains a whitespace-separated list of ELF shared objects to be loaded before running a program?</span></p>', 'hint': 'Specify the full path '}, {'questionNo': 3, 'question': '<p>If both the environment variable and the file are employed, the libraries specified by which would be loaded first?</p>', 'hint': '/etc/ld.so.preload section of man page of ld.so'}]}, {'taskTitle': 'Putting On Our Coding Hats', 'taskDesc': '<p><span style="font-size:1rem">Enough about the theory, time to get our hands dirty. So put your coding hats on and continue reading below:</span></p><p>Before we start, we need to understand how things work. In this first example, we will hook the <code>write()\ufeff</code><span style="font-size:14px;background-color:rgb(234, 234, 237)"></span><span style="font-size:1rem"> function.\xa0 First let\'s create a very simple program using </span><code>write()</code><span style="font-size:14px;background-color:rgb(234, 234, 237)"></span><span style="font-size:1rem">\xa0:\xa0\xa0</span></p><p><span style="font-size:14px"></span></p><p></p><p><code>#include\xa0&lt;unistd.h&gt;<br />int main()<br />{<br />\xa0\xa0char str[12];<br />\xa0 int s;<br />\xa0 s=read(0, str,13);\xa0 \xa0 \xa0\xa0<br />\xa0\xa0write(1, str, s);\xa0 \xa0 \xa0 \xa0 \xa0 \xa0 \xa0 \xa0 \xa0 \xa0 \xa0 \xa0 \xa0\xa0<br />\xa0\xa0return 0;<br />}</code></p><p>First things first, let\'s compile and run our example to get an output as shown:</p><p><img src="https://i.imgur.com/HlUwm67.png" style="width:50%" /><br /></p><p>Here, we basically read some input from\xa0<b>stdin</b> and print it out to <b>stdout</b>. Pretty simple, right ? (Let\'s just ignore the bad memory management). Now, let\'s take a look at what goes on behind the scenes:</p><p><img src="https://i.imgur.com/7GroQ8K.png" style="font-size:1rem;width:50%;float:right" class="note-float-right" /></p><p>Under normal circumstances, when the dynamic linker comes across the\xa0<code>write()</code><span style="color:rgb(196, 20, 20);font-family:SFMono-Regular, Menlo, Monaco, Consolas, &quot;Liberation Mono&quot;, &quot;Courier New&quot;, monospace;font-size:14px;background-color:rgb(234, 234, 237)"></span>\xa0function, it looks up its address in the standard shared libraries. On encountering the first\xa0occurrence of\xa0<code>write()</code><span style="font-size:1rem">, it passes the arguments to the function and return an output accordingly. Simple enough, right? Now it\'s time to get malicious.<br /><br />First let\'s create a little malicious Shared Library of our own. Since we are hooking the\xa0</span><code>write()</code><span style="background-color:rgb(234, 234, 237);color:rgb(196, 20, 20);font-family:SFMono-Regular, Menlo, Monaco, Consolas, &quot;Liberation Mono&quot;, &quot;Courier New&quot;, monospace;font-size:14px"></span><span style="font-size:1rem">\xa0function, first look up the full function definition and the return type from the man pages.\xa0</span></p><p><span style="font-size:1rem">From the man pages we get t</span><span style="font-size:1rem">he function definition of </span><code>write()</code><span style="font-size:1rem">\xa0as\xa0</span><code>ssize_t write(int fd, const void *buf, size_t count);</code><span style="font-size:1rem">\xa0with the return type being\xa0</span><code>ssize_t</code><span style="font-size:1rem">.</span></p><p><span style="font-size:1rem">I</span><span style="font-size:1rem">t is very important that our malicious function also has the same function definition and return type as the original function which we are trying to hook. With that out of the way, let\'s get to writing our own malicious shared library as follows:</span></p><p><code>#include &lt;stdio.h&gt;<br />#include &lt;unistd.h&gt;<br />#include &lt;dlfcn.h&gt;<br />#include &lt;string.h&gt;<br />ssize_t write(int fildes, const void *buf, size_t nbytes)<br />{<br />\xa0 \xa0 \xa0ssize_t (*new_write)(int fildes, const void *buf, size_t nbytes);\xa0<br />\xa0 \xa0 \xa0ssize_t result;<br />\xa0 \xa0 \xa0new_write = dlsym(RTLD_NEXT, "write");<br />\xa0 \xa0 \xa0if (strncmp(buf, "Hello World",strlen("Hello World")) == 0)<br />\xa0 \xa0 \xa0{<br />\xa0 \xa0 \xa0 \xa0 \xa0 result = new_write(fildes, "Hacked 1337", strlen("Hacked 1337"));<br />\xa0 \xa0 \xa0}<br />\xa0 \xa0 \xa0else<br />\xa0 \xa0 \xa0{<br />\xa0 \xa0 \xa0 \xa0 \xa0 result = new_write(fildes, buf, nbytes);<br />\xa0 \xa0 \xa0}<br />\xa0 \xa0 \xa0return result;<br />}</code></p><p>Looks complicated, does it? Trust me, it\'s not. Let\'s break this down:</p><ul><li>First, we include the necessary header files which we will need to carry out simple tasks. Pretty standard thing, right?</li><li>Next, we need to create a function with the <b>exact same function definition and return type </b>as the function we are trying to hook. This is because the programs calling the function will send a set of parameters and shall expect a particular type of output in return, failing to align to which will cause unwanted errors.<br />Since we are trying to hook the\xa0<code>write()</code><span style="color:rgb(196, 20, 20);font-family:SFMono-Regular, Menlo, Monaco, Consolas, &quot;Liberation Mono&quot;, &quot;Courier New&quot;, monospace;font-size:14px;background-color:rgb(234, 234, 237)"></span>\xa0function here, we create a function with the same name(<code>write()</code><span style="color:rgb(196, 20, 20);font-family:SFMono-Regular, Menlo, Monaco, Consolas, &quot;Liberation Mono&quot;, &quot;Courier New&quot;, monospace;font-size:14px;background-color:rgb(234, 234, 237)"></span>), set of parameters (<code>int fd, const void *buf, size_t count</code><span style="color:rgb(196, 20, 20);font-family:SFMono-Regular, Menlo, Monaco, Consolas, &quot;Liberation Mono&quot;, &quot;Courier New&quot;, monospace;font-size:14px;background-color:rgb(234, 234, 237)"></span>) and return type (<code>ssize_t</code><span style="color:rgb(196, 20, 20);font-family:SFMono-Regular, Menlo, Monaco, Consolas, &quot;Liberation Mono&quot;, &quot;Courier New&quot;, monospace;font-size:14px;background-color:rgb(234, 234, 237)"></span>) to prevent any unwanted errors. So far so good, right?</li><li>Next up, we do something VERY important : create a function pointer\xa0<code>new_write</code>\xa0with the same set of variables as the function we are trying to hook, which in this case is\xa0<code>write()</code><span style="color:rgb(196, 20, 20);font-family:SFMono-Regular, Menlo, Monaco, Consolas, &quot;Liberation Mono&quot;, &quot;Courier New&quot;, monospace;font-size:14px;background-color:rgb(234, 234, 237)"></span>, as this will later store the original address of the function which we will use later! Got it?</li><li>We also create a variable <code>result</code><span style="font-size:14px;background-color:rgb(234, 234, 237)"></span>\xa0to store the return value. Do note that it\'s the same datatype as the calling program is expecting.</li><li>Finally, we come to probably the most technical part of the program. Here we are storing the location of the original\xa0<code>write()</code><span style="color:rgb(196, 20, 20);font-family:SFMono-Regular, Menlo, Monaco, Consolas, &quot;Liberation Mono&quot;, &quot;Courier New&quot;, monospace;font-size:14px;background-color:rgb(234, 234, 237)"></span>\xa0function into the function pointer we created earlier. We use the <code>dlsym</code><span style="font-size:14px;background-color:rgb(234, 234, 237)"></span>\xa0function to get the address of next occurrence of\xa0<code>write</code><span style="color:rgb(196, 20, 20);font-family:SFMono-Regular, Menlo, Monaco, Consolas, &quot;Liberation Mono&quot;, &quot;Courier New&quot;, monospace;font-size:14px;background-color:rgb(234, 234, 237)"></span>\xa0 from the standard shared libraries (as dictated by the <code>RTLD_NEXT</code><span style="font-size:14px;background-color:rgb(234, 234, 237)"></span>\xa0flag). I will implore you to just skim through the man page for <code>dlsym</code><span style="font-size:14px;background-color:rgb(234, 234, 237)"></span>\xa0once before proceeding to get a better understanding of what\'s happening.</li></ul><p>The steps so far were pretty standard in all cases except for the usual change of names and parameters. The following steps dictate how we will be leveraging our hook and will be different for different hooks.<br /></p><ul><li>Now we have some fun. Here, we compare the string buffer passed to the function to see if it equals <i>"Hello World".</i>\xa0If it does, we call\xa0 the original\xa0<code>write()</code><span style="color:rgb(196, 20, 20);font-family:SFMono-Regular, Menlo, Monaco, Consolas, &quot;Liberation Mono&quot;, &quot;Courier New&quot;, monospace;font-size:14px;background-color:rgb(234, 234, 237)"></span>\xa0function using the function pointer but replace it with our own string and store the result returned. You can do anything you feel like : generate logs, trigger other conditions, create connections if certain conditions are met and so on. Feel free to play around this part!</li><li>If the conditions aren\'t met, however, we simply pass all the parameters to the original function via our function pointer, and store the result.</li><li>We finally return the result to the calling function.</li></ul><p>Phew, that was easy. Wasn\'t it? Take a moment, read through it if you didn\'t get any part of it but make sure you understand the steps as this is the core skeletal structure of a hook. Just to prevent this section from getting tedious, we\'ll see how to compile and load our malicious shared library in the next task.\xa0</p><p><img src="https://i.imgur.com/QaDA5cD.jpg" style="width:683px" /><br /></p>', 'taskType': 'downloadable', 'taskNo': 4, 'taskCreated': '2021-06-04T16:15:13.023Z', 'taskDeadline': None, 'tasksInfo': [], 'uploadId': '60be322aff4f44005dec93ee', 'questions': [{'questionNo': 1, 'question': 'How many arguments does <b>write()</b> take?', 'hint': ''}, {'questionNo': 2, 'question': '<p>Which\xa0feature test macro must be defined in order to obtain the\xa0 definitions\xa0 of<span style="font-size:1rem">\xa0<b>RTLD_NEXT</b> from <b>&lt;dlfcn.h&gt;</b>?\xa0</span></p>', 'hint': 'man 3 dlsym'}]}, {'taskTitle': "Let's Gooooooooo", 'taskDesc': '<p>Okay, so the last section might have been a bit draining, but I promise this section will be fun. Here we will see how to:</p><ul><li>Compile Our Program</li><li>Pre-load Our Shared Object</li><li>See It In Action\xa0</li></ul><p>With the roadmap set, let\'s get going!</p><p><span style="font-size:36px"><b>Compiling Our Program</b></span></p><p>To compile our program from the previous task, we will use the following:</p><p><code>gcc -ldl malicious.c -fPIC -shared -D_GNU_SOURCE -o malicious.so\xa0</code></p><p><i>Note : If you run into a <code>symbol lookup error</code>\xa0at any point, try the following compile statement:</i><br /></p><p><code>gcc malicious.c -fPIC -shared -D_GNU_SOURCE -o malicious.so -ldl</code><span style="color:rgb(196, 20, 20);font-family:SFMono-Regular, Menlo, Monaco, Consolas, &quot;Liberation Mono&quot;, &quot;Courier New&quot;, monospace;font-size:14px;background-color:rgb(234, 234, 237)"><br /></span><br /><span style="font-size:1rem">Like always, let\'s break down the statement to make sure that we understand all of this:</span><br /></p><ul><li><b>gcc</b> : Our very own GNU Compiler Collection.</li><li><span style="font-weight:bolder">-ldl</span>\xa0: Link against\xa0<span style="font-weight:bolder">libdl\xa0</span>aka the dynamic linking library.</li><li><b>malicious.c</b> : The name of our program.\xa0</li><li><b>-fPIC</b> : Generate position-independent code. (Excellent answer on why this is needed can be found <a href="https://stackoverflow.com/questions/966960/what-does-fpic-mean-when-building-a-shared-library" target="_blank">here</a>).</li><li><b>-shared</b> : Tells the compiler to create a Shared Object which can be linked with other objects to produce an executable.</li><li><b>-D_GNU_SOURCE </b>: It is specified to satisfy <b>#ifdef</b> conditions that allow us to use the <b>RTLD_NEXT</b> enum (Yes, this is what I was talking about in Question #2 of Task 4) . Optionally this flag can be replaced by adding\xa0<code>#define _GNU_SOURCE</code><span style="font-size:1rem">.</span></li><li><b>-o</b> : Specify the name of the output executable.</li><li><b>malicious.so</b> : Name of output file.</li></ul><p>With this done, we should have a\xa0<code>malicious.so</code><span style="background-color:rgb(234, 234, 237);color:rgb(196, 20, 20);font-family:SFMono-Regular, Menlo, Monaco, Consolas, &quot;Liberation Mono&quot;, &quot;Courier New&quot;, monospace;font-size:14px"></span><span style="font-size:1rem">\xa0object file ready to hook a function, just waiting to be pre-loaded!</span></p><p><span style="font-weight:bolder;font-size:36px">Pre-Loading Our Shared Object</span><span style="font-size:1rem"><br /></span></p><p><span style="font-size:1rem">Now that we have our Shared Object file ready, we need to pre-load it before other shared library objects to successfully hook our function. To do this, we have two methods to do this:</span></p><ul><li><span style="font-size:1rem">Using <b>LD_PRELOAD</b></span></li><li><span style="font-size:1rem">Using<b>\xa0</b></span><b>/etc/ld.so.preload</b> file</li></ul><p>If you have been following along, you know that if both are specified, then the libraries specified by <b>LD_PRELOAD</b> are loaded first<span style="font-size:1rem">\xa0Both the methods have their pros and cons depending on the situation, but I personally prefer the latter because we can easily hide the\xa0</span><span style="font-weight:bolder;font-size:1rem">/etc/ld.so.preload </span><span style="font-size:1rem">file using this very same method (explained in a later Task) and not the <i>dot-before-filename</i> way. Below is the syntax for pre-loading the shared object using each method:</span></p><p><span style="font-size:24px"><b>Using LD_PRELOAD:</b></span></p><p><code>export LD_PRELOAD=$(pwd)/malicious.so</code></p><p><span style="font-weight:bolder;font-size:24px">Using /etc/ld.so.preload:</span><br /></p><p><code>sudo sh -c "echo $(pwd)/malicious.so &gt; /etc/ld.so.preload"</code><span style="font-size:1rem"><br /></span></p><p><span style="font-size:1rem"><i>Note : Both of these commands must be run from the directory containing the shared object file. Ideally, you would want to store them somewhere like /lib or /usr/lib depending on where your system stores the shared library object files so as not to arouse suspicion.</i></span></p><p><span style="font-size:1rem">You can verify if your shared object was successfully loaded by doing a simple:</span></p><p><code>$ ldd /bin/ls<br />\xa0 \xa0 \xa0linux-gate.so.1 (0xb7fc0000)<br />\xa0 \xa0 \xa0/home/whokilleddb/malicious.so\xa0 (0xb7f8f000)<br />\xa0 \xa0 \xa0libselinux.so.1 =&gt; /lib/i386-linux-gnu/libselinux.so.1 (0xb7f43000)<br />\xa0 \xa0 \xa0libc.so.6 =&gt; /lib/i386-linux-gnu/libc.so.6 (0xb7d65000)<br />\xa0 \xa0 \xa0lbdl.so.2 =&gt; /lib/i386-linux-gnu/libdl.so.2 (0xb7d5f000)<br />\xa0 \xa0 \xa0libpcre.so.3 =&gt; /lib/i386-linux-gnu/libpcre.so.3 (0xb7ce6000)<br />\xa0 \xa0 \xa0/lib/ld-linux.so.2 (0xb7fc2000)<br />\xa0 \xa0 \xa0libpthread.so.0 =&gt; /lib/i386-linux-gnu/libpthread.so.0 (0xb7cc5000)<br /><br /></code></p><p>[Awesome Explanation about that first\xa0<code>linux-gate.so.1</code><span style="font-size:1rem">\xa0library </span><a href="https://www.technovelty.org/linux/a-little-tour-of-linux-gateso.html" target="_blank">here</a><span style="font-size:1rem">]</span></p><p>The important thing to notice is that our malicious shared object is being loaded before the standard shared libraries.</p><p><img src="https://i.imgur.com/cS21UEX.png" style="width:50%;float:right" class="note-float-right" />So now the scenario is something like this: The program makes a call to the\xa0<code>write()</code><span style="background-color:rgb(234, 234, 237);color:rgb(196, 20, 20);font-family:SFMono-Regular, Menlo, Monaco, Consolas, &quot;Liberation Mono&quot;, &quot;Courier New&quot;, monospace;font-size:14px"></span><span style="font-size:1rem">\xa0function with all the parameters in place. However, instead of going to the<b> libc </b>definition of\xa0</span><code>write()</code><span style="background-color:rgb(234, 234, 237);color:rgb(196, 20, 20);font-family:SFMono-Regular, Menlo, Monaco, Consolas, &quot;Liberation Mono&quot;, &quot;Courier New&quot;, monospace;font-size:14px"></span><span style="font-size:1rem">\xa0it goes to our malicious shared object as the dynamic linker finds the <b>FIRST OCCURRENCE</b> of\xa0</span><code>write()</code><span style="background-color:rgb(234, 234, 237);color:rgb(196, 20, 20);font-family:SFMono-Regular, Menlo, Monaco, Consolas, &quot;Liberation Mono&quot;, &quot;Courier New&quot;, monospace;font-size:14px"></span><span style="font-size:1rem">\xa0and lets it do its thing, which in our case is a simple comparison operation which, if true, returns the malicious/tampered output, else passes on the parameters onto the real function inside<b> libc</b> and passes the output obtained back to the program. </span></p><p><span style="font-size:1rem">Pretty straight forward, right ? This process is roughly similar to the <b>PATH </b>Hijacking method which is widely used during CTFs and Pentests, so if you understand that well, this should be a breeze for you.</span></p><p><span style="font-size:1rem">\xa0Finally,\xa0 we can move to our final stage, which is seeing our malicious shared object in action!</span></p><p><span style="font-size:36px"><b>Seeing It In Action</b></span></p><div>Remember the little "Hello World" Program we created ? Let\'s re-run it now with our malicious shared object pre-loaded and ready !\xa0If we run it this time we will see something fun. Instead of the "Hello World" string being echoed back, we will see "Hacked 1337", courtesy of our malicious shared object.</div><div><br /></div><div>But does it stop there? NO.\xa0Manyyyyyyyyyyyyy other programs (as obvious by the excess trailing \'y\'s) use libc to do their work for them. <code>write()</code> is a very common functionality and is frequently invoked. This will affect all such programs.</div><div><br /></div><div><img src="https://i.imgflip.com/5cwjuq.jpg" style="width:50%" /><br /></div><div><br /></div><div>For example, if you create a file with the text <i>"Hello World"</i> and try to <b>cat</b> it out, we will get <i>"Hacked 1337"</i> as output. Same results will follow if we used <b>python3</b> to print the same because at some level, they all are using the\xa0<code>write()</code><span style="background-color:rgb(234, 234, 237);color:rgb(196, 20, 20);font-family:SFMono-Regular, Menlo, Monaco, Consolas, &quot;Liberation Mono&quot;, &quot;Courier New&quot;, monospace;font-size:14px"></span><span style="font-size:1rem">\xa0function which has already been hooked. So now you can imagine the wide array of things you can achieve with hooking functions instead of just swapping text.</span></div><div><br /></div><div><img src="https://i.imgur.com/iMXZTMG.png" style="width:50%" /><br /></div><div><br /></div><div><i>Note: Make sure that the string you are replacing and the string you are replacing it with have the same number of characters to prevent memory flaws</i></div><div><br /></div><div>So that was all about hooking the\xa0<code>write()</code><span style="background-color:rgb(234, 234, 237);color:rgb(196, 20, 20);font-family:SFMono-Regular, Menlo, Monaco, Consolas, &quot;Liberation Mono&quot;, &quot;Courier New&quot;, monospace;font-size:14px"></span><span style="font-size:1rem">\xa0function. Though we did not play around with the function much, but it is to be noted that this can be used to trigger a lot of other events. For example many services use the\xa0</span><code>write()</code><span style="background-color:rgb(234, 234, 237);color:rgb(196, 20, 20);font-family:SFMono-Regular, Menlo, Monaco, Consolas, &quot;Liberation Mono&quot;, &quot;Courier New&quot;, monospace;font-size:14px"></span><span style="font-size:1rem">\xa0function to generate logs and if we are able to trigger a switch (for example by passing "Hello World" or some other switch as a username or in the User Agent of a request, which will then be passed as an argument to\xa0</span><code>write()</code><span style="background-color:rgb(234, 234, 237);color:rgb(196, 20, 20);font-family:SFMono-Regular, Menlo, Monaco, Consolas, &quot;Liberation Mono&quot;, &quot;Courier New&quot;, monospace;font-size:14px"></span><span style="font-size:1rem">\xa0at some point), we can spawn reverse/bind shells, delete files, exfiltrate data, etc.</span></div><div><br />That being said, we will have a look at some more interesting things we can do with Function Hooking and have fun hooking onto a few more <b>libc</b> functions in the upcoming tasks.</div>', 'taskType': 'none', 'taskNo': 5, 'taskCreated': '2021-06-07T16:57:16.310Z', 'taskDeadline': None, 'tasksInfo': [], 'uploadId': '', 'questions': [{'questionNo': 1, 'question': 'When compiling our code to produce a Shared Object, which flag is used to create position independent code?', 'hint': ''}, {'questionNo': 2, 'question': '<p>Can hooking libc functions affect the behavior of Python3? (Yay/Nay)</p>', 'hint': ''}]}, {'taskTitle': 'Hiding Files From ls', 'taskDesc': '<p>Now that we know how to use Shared Objects to hook various functions, let\'s learn how to hide files from the <code>ls</code><span style="font-size:14px;background-color:rgb(234, 234, 237)"></span><span style="font-size:1rem">\xa0command in a more efficient way than just <i>putting-a-dot-before-filename.</i></span></p><p>Before we attack the\xa0<code>ls</code><span style="background-color:rgb(234, 234, 237);color:rgb(196, 20, 20);font-family:SFMono-Regular, Menlo, Monaco, Consolas, &quot;Liberation Mono&quot;, &quot;Courier New&quot;, monospace;font-size:14px"></span><span style="font-size:1rem">\xa0 command, we need to understand how it actually works. I will not go into details of the entire thing here (people are getting angry at the long tasks) but </span><a href="https://gist.github.com/amitsaha/8169242" target="_blank">here\'s an excellent resource</a><span style="font-size:1rem"> to understand the command, and it\'s workings in depth.</span></p><p style="orphans:3;widows:3">The primary thing which we need to know here that the command uses a function called <code>readdir()</code> which returns a pointer to the next <code>dirent</code> structure in the directory. A\xa0<code>dirent</code>\xa0is a C - structure who\'s <b>glibc</b> definition can be obtained from the man page of <b>readdir</b>:\xa0</p><p><code>struct dirent {<br />\xa0 \xa0 \xa0ino_t\xa0 \xa0 \xa0 \xa0 \xa0 d_ino;\xa0 \xa0 \xa0 \xa0/* Inode number */<br />\xa0 \xa0 \xa0off_t\xa0 \xa0 \xa0 \xa0 \xa0 d_off;\xa0 \xa0 \xa0 \xa0/* Not an offset; see below */<br />\xa0 \xa0 \xa0unsigned short d_reclen;\xa0 \xa0 /* Length of this record */<br />\xa0 \xa0 \xa0unsigned char\xa0 d_type;\xa0 \xa0 \xa0 /* Type of file; not supported not supported by all filesystem types */\xa0\xa0<br />\xa0 \xa0 \xa0char\xa0 \xa0 \xa0 \xa0 \xa0 \xa0d_name[256]; /* Null-terminated filename */<br />\xa0 \xa0 \xa0};</code><span style="font-size:1rem"></span></p><p><span style="font-size:1rem">The main parameter which we are concerned about here is the </span><code>d_name[256]</code><span style="font-size:1rem"> which is a mandatory field and contains the name of the various files in our a directory. (See where I am going with this ?)</span></p><p>So here\'s the roadmap:</p><ul><li><code>ls</code> uses <code>readdir()</code> function to get the contents of a directory</li><li>The <code>readdir()</code> function returns a pointer to a <code>dirent</code> structure to the next directory entry</li><li>The <code>dirent</code> structure contains a <code>d_name</code> parameter which contains the name of the file</li><li>Thus, we hook the <code>readdir()</code> function</li><li>Then we pass the parameters to the original function and check whether the <code>d_name</code> parameter of the <code>dirent</code> whose pointer is being returned is equal to a given a filename</li><li>If yes, we skip it and pass on the rest.</li></ul><p>With the map all set, let\'s get to coding!<span style="font-size:1rem">\xa0</span></p><p><code>#include &lt;string.h&gt;<br />#include &lt;stdlib.h&gt;<br />#include &lt;dirent.h&gt;<br />#include &lt;dlfcn.h&gt;<br /><br />#define FILENAME "ld.so.preload"<br /><br />struct dirent *readdir(DIR *dirp)<br />{<br />\xa0 \xa0 \xa0struct dirent *(*old_readdir)(DIR *dir);\xa0 \xa0 \xa0<br />\xa0 \xa0 \xa0old_readdir = dlsym(RTLD_NEXT, "readdir");<br />\xa0 \xa0 \xa0struct dirent *dir;<br />\xa0 \xa0 \xa0while (dir = old_readdir(dirp))<br />\xa0 \xa0 \xa0{<br />\xa0 \xa0 \xa0 \xa0 \xa0 \xa0if(strstr(dir-&gt;d_name,FILENAME) == 0) break;\xa0 \xa0 \xa0<br />\xa0 \xa0 \xa0}<br />\xa0 \xa0 \xa0return dir;<br />}<br /><br />struct dirent64 *readdir64(DIR *dirp)<br />{<br />\xa0 \xa0 \xa0struct dirent64 *(*old_readdir64)(DIR *dir);\xa0 \xa0 \xa0<br />\xa0 \xa0 \xa0old_readdir64 = dlsym(RTLD_NEXT, "readdir64");<br />\xa0 \xa0 \xa0struct dirent64 *dir;<br />\xa0 \xa0 \xa0while (dir = old_readdir64(dirp))<br />\xa0 \xa0 \xa0{<br />\xa0 \xa0 \xa0 \xa0 \xa0 \xa0if(strstr(dir-&gt;d_name,FILENAME) == 0) break;<br />\xa0 \xa0 \xa0}<br />\xa0 \xa0 \xa0return dir;<br />}</code></p><p><i>[Note : The readdir64 is just the 64-bit version of the same and follows the same concepts so don\'t worry about it !]</i></p><p>Breaking down our hook, we have:</p><ul><li>First we declare our usual headers with the extra <code>#include &lt;dirent.h&gt;</code> header which contains the definition of the <code>dirent</code> structure</li><li>Then, we do our usual hooking stuff: creating a function with the same definition and return type, create a function pointer and use <code>dlsym</code> to store the value of the original function in it.</li><li>Finally coming to the most crucial part, we create a while loop and fetch the pointer to the next <code>dirent</code> structure in the\xa0directory stream pointed to by <code>dirp</code> and check if the <code>d_name</code> parameter contains our string. If it doesn\'t (which is denoted by an output <b>0</b> as a result of the <code>strstr</code> function), we simply break from the loop and return the value as obtained from the original function. However, if we have a match, we iterate one more time, thereby effectively skipping over our file a return pointer to the <b>dirent</b> structure pertaining to the next file in the directory.</li></ul><p>It is to be noted that you can still modify the file or cat out its contents. However, it will not show in the output of the <code>ls</code> command! This can be very useful if you want to hide malicious files, alter filenames, etc. One very popular use is to hide the <code>/etc/ld.so.preload</code> file or the shared object itself!</p><p><img src="https://i.imgur.com/2z6edCu.png" style="width:1074.67px" /><br /></p><p>As you can see in the screenshot, when the malicious shared object was loaded, <code>ls</code> did not list our file in its output. However, we were still able to read its contents by specifically mentioning its path. Hence, you can hide files in plain sight which no-one but you would know about. Wasn\'t that pretty cool?</p><p><i>[Note : If you are stuck, <a href="https://www.linuxfordevices.com/tutorials/linux/hiding-files-in-linux-with-c" target="_blank">here\'s an article I wrote</a> on this very topic]</i></p>', 'taskType': 'downloadable', 'taskNo': 6, 'taskCreated': '2021-06-08T05:14:47.248Z', 'taskDeadline': None, 'tasksInfo': [], 'uploadId': '60bf4f3129bbbc006946c4d2', 'questions': [{'questionNo': 1, 'question': 'There are two mandatory fields of a <b>dirent</b> structure. One is <b>d_name</b>, and the other one is?', 'hint': 'man 3 readdir'}, {'questionNo': 2, 'question': '<p>I have read and understood how I can hide files using shared objects!</p>', 'hint': ''}]}, {'taskTitle': 'Conclusion', 'taskDesc': '<p>So we saw what are shared libraries, wrote some code, pre-loaded our malicious object files, had some fun playing around. But we have barely touched the tip of the iceberg here. Here are some ideas you can try on your own:</p><ul><li>Popping up bind and reverse shells by hooking <code>write()</code> based on certain triggers</li><li>Hiding connections from <b>netsat</b> and <b>lsof</b> by hooking the function\xa0<code>fopen()</code></li><li>Logging requests by hooking <code>SSL_write()</code></li><li>And a lot more!</li></ul><p>With that, we reach the end of this room. You can follow me on <a href="https://twitter.com/whokilleddb" target="_blank">Twitter</a>\xa0or reach out to me on the TryHackMe discord :D</p>', 'taskType': 'none', 'taskNo': 7, 'taskCreated': '2021-06-08T11:15:27.685Z', 'taskDeadline': None, 'tasksInfo': [], 'uploadId': '', 'questions': [{'questionNo': 1, 'question': 'Hooray! You made it to the end!', 'hint': ''}]}]}